<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LOOP MACHINE</title>
<script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>
<style>
*, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }
body {
  overflow:hidden; background:#000; color:#e0e0ff;
  font-family:'Courier New',Courier,monospace; font-size:13px; user-select:none;
}
#canvas-container { position:fixed; inset:0; z-index:0; }

/* â”€â”€ PANEL â”€â”€ */
#panel {
  position:fixed; top:calc(100vh - 500px); left:calc(50% - min(340px, 47.5vw));
  width:min(680px,95vw); max-height:calc(100vh - 24px); overflow-y:auto; z-index:100;
  background:rgba(8,0,18,0.82); backdrop-filter:blur(22px); -webkit-backdrop-filter:blur(22px);
  border:1px solid rgba(180,0,255,0.35); border-radius:14px; padding:0 18px 10px;
  box-shadow:0 0 40px rgba(120,0,255,0.15), inset 0 0 60px rgba(0,0,0,0.3);
  scrollbar-width:thin; scrollbar-color:rgba(180,0,255,0.3) transparent;
  resize:both;
}
#panel-drag {
  cursor:grab; padding:8px 0 4px; text-align:center; user-select:none;
  border-bottom:1px solid rgba(180,0,255,0.15); margin:0 -18px 8px; padding-left:18px; padding-right:18px;
}
#panel-drag:active { cursor:grabbing; }
#panel-drag::after {
  content:''; display:block; width:40px; height:3px; margin:6px auto 0;
  background:rgba(180,0,255,0.3); border-radius:2px;
}
#panel::-webkit-scrollbar { width:5px; }
#panel::-webkit-scrollbar-thumb { background:rgba(180,0,255,0.3); border-radius:3px; }
#panel h1 { text-align:center; font-size:14px; letter-spacing:6px; color:#c060ff; margin:0; text-shadow:0 0 12px #a020f0; }

/* rows */
.row { display:flex; align-items:center; gap:8px; margin:4px 0; }
.row label { width:44px; text-transform:uppercase; font-size:10px; letter-spacing:1px; color:#9080b0; flex-shrink:0; }
.row .val { width:44px; text-align:right; font-size:11px; color:#c0b0ff; flex-shrink:0; }

/* slider grid */
.slider-grid { display:grid; grid-template-columns:1fr 1fr; gap:2px 14px; margin:4px 0; }
.si { display:flex; align-items:center; gap:6px; }
.si label { width:38px; text-transform:uppercase; font-size:9px; letter-spacing:1px; color:#9080b0; flex-shrink:0; }
.si input[type=range] { flex:1; }
.si .val { width:38px; text-align:right; font-size:10px; color:#c0b0ff; flex-shrink:0; }

/* range inputs */
input[type=range] {
  -webkit-appearance:none; height:5px; border-radius:3px;
  background:rgba(255,255,255,0.08); outline:none;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance:none; width:14px; height:14px; border-radius:50%;
  background:radial-gradient(circle,#d060ff 30%,#7010c0 100%); box-shadow:0 0 6px #b040ff; cursor:pointer;
}
input[type=range]::-moz-range-thumb {
  width:14px; height:14px; border-radius:50%; border:none;
  background:radial-gradient(circle,#d060ff 30%,#7010c0 100%); box-shadow:0 0 6px #b040ff; cursor:pointer;
}

/* buttons */
.btn {
  padding:5px 12px; border-radius:5px; border:1px solid rgba(180,0,255,0.4);
  background:rgba(40,0,60,0.6); color:#d0b0ff; cursor:pointer;
  font-family:inherit; font-size:11px; letter-spacing:1px; transition:all .12s;
}
.btn:hover { background:rgba(100,0,180,0.5); box-shadow:0 0 10px rgba(180,0,255,0.4); }
.btn.active { background:rgba(180,0,255,0.45); border-color:#c060ff; color:#fff; }
.btn:disabled { opacity:0.4; cursor:default; }

.loop-btns { display:flex; gap:3px; }
.loop-btns .btn { min-width:28px; text-align:center; padding:3px 6px; }

/* progress */
.progress-wrap { width:100%; height:4px; background:rgba(255,255,255,0.06); border-radius:2px; margin:6px 0 2px; position:relative; }
.progress-bar { height:100%; border-radius:2px; background:linear-gradient(90deg,#ff00ff,#00ffff); width:0%; transition:width .04s linear; }
.progress-label { position:absolute; right:0; top:-13px; font-size:9px; color:#8070a0; }

.divider { height:1px; background:linear-gradient(90deg,transparent,rgba(180,0,255,0.3),transparent); margin:8px 0; }

/* â”€â”€ STEP SEQUENCER â”€â”€ */
.seq-header { display:flex; align-items:center; gap:8px; margin-bottom:4px; }
.seq-header span { font-size:10px; letter-spacing:2px; color:#8070a0; text-transform:uppercase; }
.bar-tabs { display:flex; gap:3px; margin-left:auto; }
.bar-tabs .btn { font-size:9px; padding:2px 7px; min-width:22px; }

.seq-row { display:flex; align-items:center; gap:2px; margin:1px 0; }
.seq-label {
  width:28px; font-size:9px; font-weight:bold; letter-spacing:1px;
  text-align:right; padding-right:3px; flex-shrink:0;
}
.seq-step {
  flex:1; height:18px; min-width:0; border-radius:2px;
  border:1px solid rgba(255,255,255,0.06);
  background:rgba(20,0,40,0.3); cursor:pointer; transition:background .06s;
  display:flex; align-items:center; justify-content:center;
  font-size:8px; font-weight:bold; color:rgba(255,255,255,0.7);
}
.seq-row.muted { opacity:0.3; }
.seq-row.forced .seq-label { text-shadow:0 0 6px currentColor; }
.seq-label { cursor:pointer; }
.seq-step.beat-start { border-left:1px solid rgba(180,0,255,0.3); }
.seq-step.on { box-shadow:inset 0 0 6px rgba(255,255,255,0.15); }
.seq-step.current { border-color:rgba(0,255,255,0.7) !important; box-shadow:inset 0 0 8px rgba(0,255,255,0.25); }
.seq-step:hover { border-color:rgba(180,0,255,0.5); }

/* beat number markers */
.seq-nums { display:flex; gap:2px; margin-left:30px; margin-bottom:1px; }
.seq-nums span { flex:1; text-align:center; font-size:7px; color:#605080; }
.seq-nums span.beat-num { color:#9080b0; }

/* textures */
.tex-row { display:flex; gap:5px; align-items:center; margin:4px 0; flex-wrap:wrap; }
.tex-row input[type=text] {
  flex:1; min-width:100px; padding:4px 8px; border-radius:4px;
  border:1px solid rgba(180,0,255,0.3); background:rgba(20,0,40,0.6); color:#d0b0ff;
  font-family:inherit; font-size:11px; outline:none;
}
.tex-row input[type=text]:focus { border-color:#c060ff; }
.presets { display:flex; gap:3px; flex-wrap:wrap; margin:3px 0; }
.presets .btn { font-size:9px; padding:2px 7px; }
.gallery { display:flex; gap:4px; margin-top:4px; flex-wrap:wrap; }
.gallery img { width:42px; height:42px; border-radius:4px; object-fit:cover; cursor:pointer; border:2px solid transparent; transition:border .12s; }
.gallery img:hover { border-color:#c060ff; }
.gallery img.sel { border-color:#00ffff; }

.settings { max-height:0; overflow:hidden; transition:max-height .3s ease; }
.settings.open { max-height:120px; }
.settings-row { display:flex; gap:5px; align-items:center; margin:4px 0; }
.settings-row input[type=text] { flex:1; padding:4px 8px; border-radius:4px; border:1px solid rgba(180,0,255,0.3); background:rgba(20,0,40,0.6); color:#d0b0ff; font-family:inherit; font-size:10px; outline:none; }

.toggle-row { display:flex; gap:6px; align-items:center; justify-content:center; margin:3px 0; }
.status { text-align:center; font-size:9px; color:#6050a0; margin-top:3px; min-height:12px; }
.section-title { font-size:9px; letter-spacing:2px; color:#8070a0; text-transform:uppercase; margin:2px 0; }

/* sample bank */
.sample-bank { max-height:140px; overflow-y:auto; margin:3px 0; }
.sample-item {
  display:flex; align-items:center; gap:3px; padding:3px 5px; margin:2px 0;
  background:rgba(20,0,40,0.4); border-radius:4px; border:1px solid rgba(255,255,255,0.05);
}
.sample-item .s-name { flex:1; font-size:9px; color:#c0b0ff; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.sample-item .s-dur { font-size:8px; color:#6050a0; min-width:24px; text-align:right; }
.sample-item .btn { font-size:7px; padding:1px 4px; min-width:0; letter-spacing:0; }
.map-item {
  display:flex; align-items:center; gap:4px; padding:2px 5px; margin:1px 0;
  background:rgba(20,0,40,0.4); border-radius:3px; border:1px solid rgba(255,255,255,0.05);
}
.map-item .m-name { flex:1; font-size:9px; color:#c0b0ff; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.map-item .m-info { font-size:7px; color:#605080; min-width:60px; text-align:right; }
.map-item .btn { font-size:7px; padding:1px 4px; min-width:0; letter-spacing:0; }
.slot-indicator { display:inline-block; font-size:7px; padding:0 3px; border-radius:2px; margin-left:2px; }
.ace-dot { display:inline-block; width:6px; height:6px; border-radius:50%; margin-right:4px; vertical-align:middle; }
.ace-dot.on { background:#44ff44; box-shadow:0 0 4px #44ff44; }
.ace-dot.off { background:#ff4444; box-shadow:0 0 4px #ff4444; }

/* sample mixer */
.mix-row {
  display:flex; align-items:center; gap:5px; margin:2px 0; padding:3px 5px;
  background:rgba(20,0,40,0.4); border-radius:4px; border:1px solid rgba(255,255,255,0.05);
}
.mix-row .mix-label { font-size:9px; font-weight:bold; width:20px; flex-shrink:0; }
.mix-row .mix-name { font-size:8px; color:#a090c0; width:80px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; flex-shrink:0; }
.mix-row input[type=range] { flex:1; height:4px; }
.mix-row .mix-db { font-size:8px; color:#8070a0; width:30px; text-align:right; flex-shrink:0; }
.mix-row .btn { font-size:8px; padding:2px 5px; min-width:0; }
.mix-row .btn.muted { background:rgba(255,60,60,0.4); border-color:#ff4444; color:#ff8888; }
.mix-empty { font-size:8px; color:#504070; text-align:center; padding:4px; }

/* tag chips */
.tag-chip { font-size:8px !important; padding:1px 5px !important; letter-spacing:0 !important; }
.tag-chip.selected { background:rgba(180,0,255,0.45); border-color:#c060ff; color:#fff; }
.tag-chip.subgenre { border-color:rgba(0,255,255,0.3); }
.tag-chip.subgenre:hover { border-color:rgba(0,255,255,0.6); box-shadow:0 0 8px rgba(0,255,255,0.3); }

/* tag cascade */
#tag-cascade { min-height:30px; }
.tag-breadcrumb-item { font-size:8px; color:#8070a0; cursor:pointer; transition:color .12s; }
.tag-breadcrumb-item:hover { color:#c060ff; }
.tag-breadcrumb-item.current { color:#c060ff; cursor:default; }
.tag-breadcrumb-sep { font-size:7px; color:#504070; }
.tag-spinner { display:inline-block; width:8px; height:8px; border:2px solid rgba(180,0,255,0.3); border-top-color:#c060ff; border-radius:50%; animation:tag-spin .6s linear infinite; vertical-align:middle; }
@keyframes tag-spin { to { transform:rotate(360deg); } }

/* preview playing */
.btn.previewing { background:rgba(255,60,60,0.4); border-color:#ff4444; color:#ff8888; }

/* modals */
.modal-overlay {
  position:fixed; inset:0; z-index:200;
  background:rgba(0,0,0,0.85); backdrop-filter:blur(8px);
  display:flex; align-items:center; justify-content:center;
}
.modal-content {
  background:rgba(8,0,18,0.95);
  border:1px solid rgba(180,0,255,0.4); border-radius:12px;
  padding:16px; box-shadow:0 0 60px rgba(120,0,255,0.2);
}
.lib-item {
  display:flex; align-items:center; gap:6px; padding:6px 8px; margin:3px 0;
  background:rgba(20,0,40,0.5); border-radius:6px; border:1px solid rgba(255,255,255,0.06);
}
.lib-item .lib-name {
  flex:1; font-size:11px; color:#d0b0ff; cursor:pointer;
  overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
}
.lib-item .lib-meta { font-size:8px; color:#605080; min-width:50px; text-align:right; }
.lib-item .btn { font-size:8px; padding:2px 6px; }
.lib-slots { display:flex; gap:2px; }

/* arranger */
.arr-track { display:flex; gap:2px; align-items:center; overflow-x:auto; padding:3px 0; scrollbar-width:thin; scrollbar-color:rgba(180,0,255,0.3) transparent; }
.arr-block {
  min-width:36px; height:28px; border-radius:3px;
  border:1px solid rgba(180,0,255,0.3); background:rgba(40,0,60,0.5);
  display:flex; align-items:center; justify-content:center;
  font-size:9px; font-weight:bold; color:#c0b0ff; cursor:pointer;
  transition:all .12s; flex-shrink:0; position:relative;
}
.arr-block:hover { border-color:#c060ff; background:rgba(80,0,120,0.5); }
.arr-block.active { border-color:#00ffff; box-shadow:0 0 6px rgba(0,255,255,0.3); }
.arr-block.bridge { background:rgba(0,60,60,0.5); border-color:rgba(0,180,180,0.3); color:#80e0e0; font-style:italic; }
.arr-block .arr-x {
  position:absolute; top:-4px; right:-4px; width:12px; height:12px;
  border-radius:50%; background:#ff4444; color:#fff; font-size:7px;
  display:none; align-items:center; justify-content:center; cursor:pointer;
  line-height:12px; text-align:center;
}
.arr-block:hover .arr-x { display:flex; }

/* â”€â”€ LORA STUDIO â”€â”€ */
.collapse-section { margin:4px 0; }
.collapse-header {
  display:flex; align-items:center; gap:6px; cursor:pointer; padding:2px 0;
}
.collapse-header .collapse-arrow { font-size:8px; color:#8070a0; transition:transform .2s; display:inline-block; }
.collapse-header .collapse-arrow.open { transform:rotate(90deg); }
.collapse-body { display:none; padding:4px 0; }
.collapse-body.open { display:block; }
.lora-section { margin:4px 0; }
.lora-header {
  display:flex; align-items:center; gap:6px; cursor:pointer; padding:2px 0;
}
.lora-header .lora-arrow { font-size:8px; color:#8070a0; transition:transform .2s; display:inline-block; }
.lora-header .lora-arrow.open { transform:rotate(90deg); }
.lora-body { display:none; padding:4px 0; }
.lora-body.open { display:block; }
.lora-dot {
  width:8px; height:8px; border-radius:50%; background:#444; display:inline-block; flex-shrink:0;
  transition:background .2s, box-shadow .2s;
}
.lora-dot.loaded { background:#00cc66; box-shadow:0 0 6px rgba(0,204,102,0.5); }
.lora-dot.active { background:#00ffff; box-shadow:0 0 8px rgba(0,255,255,0.5); }
.lora-adapters {
  max-height:100px; overflow-y:auto; margin:3px 0; scrollbar-width:thin;
  scrollbar-color:rgba(180,0,255,0.3) transparent;
}
.lora-adapter-item {
  display:flex; align-items:center; gap:6px; padding:3px 6px; border-radius:3px;
  cursor:pointer; font-size:9px; color:#c0b0ff; transition:background .12s;
}
.lora-adapter-item:hover { background:rgba(80,0,120,0.4); }
.lora-adapter-item .lora-ckpts { font-size:8px; color:#605080; margin-left:auto; }
.lora-progress-wrap {
  width:100%; height:6px; background:rgba(255,255,255,0.06); border-radius:3px; margin:4px 0;
}
.lora-progress-bar {
  height:100%; border-radius:3px; width:0%; transition:width .3s;
  background:linear-gradient(90deg,#ff00ff,#00ffff);
}
.lora-status-text { font-size:8px; color:#8070a0; margin:2px 0; word-break:break-all; }
.lora-input {
  flex:1; padding:3px 6px; border-radius:3px; border:1px solid rgba(180,0,255,0.3);
  background:rgba(20,0,40,0.6); color:#d0b0ff; font-family:inherit; font-size:10px; outline:none;
}
.lora-input:focus { border-color:#c060ff; }
</style>
</head>
<body>
<div id="canvas-container"></div>

<div id="panel">
  <div id="panel-drag">
    <h1>LOOP MACHINE</h1>
  </div>

  <!-- transport -->
  <div class="row" style="justify-content:center; gap:8px; margin-bottom:6px;">
    <button class="btn" id="play-btn" style="min-width:80px;">&#9654; PLAY</button>
    <button class="btn" id="rand-btn">RANDOMIZE</button>
    <button class="btn" id="settings-toggle" style="font-size:13px;">&#9881;</button>
  </div>

  <!-- main controls -->
  <div class="slider-grid">
    <div class="si" title="Tempo in beats per minute. 60-90 = chill/ambient, 90-130 = house/hip-hop, 130-150 = trance/techno, 150-200 = DnB/hardcore.">
      <label>BPM</label>
      <input type="range" id="bpm" min="60" max="200" value="128" step="1">
      <span class="val" id="bpm-val">128</span>
    </div>
    <div class="si" title="Intensity â€” controls how many layers play at once. Low = kick + bass only. Mid = adds hats, claps, acid. High = everything including lead, pads, stabs. Small moves add/remove entire instruments.">
      <label>INT</label>
      <input type="range" id="intensity" min="0" max="1" value="0.5" step="0.01">
      <span class="val" id="int-val">0.50</span>
    </div>
    <div class="si" title="Master lowpass filter cutoff (60-20kHz). Below ~1000 sounds muffled/dark, above ~8000 is wide open. Very sensitive in the low range â€” small moves at the bottom cut a lot of highs.">
      <label>FLT</label>
      <input type="range" id="filter" min="60" max="20000" value="4000" step="1">
      <span class="val" id="flt-val">4000</span>
    </div>
    <div class="si" title="Swing â€” shifts every other 16th note later in time for a groovy, less mechanical feel. 0 = straight, 0.5 = maximum shuffle. Even small amounts (0.05-0.15) are noticeable.">
      <label>SWG</label>
      <input type="range" id="swing" min="0" max="0.5" value="0" step="0.01">
      <span class="val" id="swg-val">0</span>
    </div>
  </div>

  <!-- sound design -->
  <div class="collapse-section">
    <div class="divider"></div>
    <div class="collapse-header" data-collapse="sound-body">
      <span class="collapse-arrow open">&#9654;</span>
      <span class="section-title" style="margin:0;">SOUND DESIGN</span>
    </div>
    <div class="collapse-body open" id="sound-body">
      <div class="slider-grid">
        <div class="si" title="Bass note decay â€” how long each bass note rings. Short (0.02-0.08) = tight staccato hits. Long (0.2-0.5) = boomy, sustained bass. Very audible even with small changes.">
          <label>BASS</label>
          <input type="range" id="bass-decay" min="0.02" max="0.5" value="0.08" step="0.01">
          <span class="val" id="bd-val">0.08</span>
        </div>
        <div class="si" title="Acid line filter resonance (Q). Controls the squelchy character of the 303-style synth. Low (1-5) = subtle, smooth. High (15-25) = screaming, self-oscillating acid. Gets wild fast above 18.">
          <label>RESO</label>
          <input type="range" id="acid-reso" min="1" max="25" value="14" step="0.5">
          <span class="val" id="ar-val">14</span>
        </div>
        <div class="si" title="Acid LFO rate â€” speed of the filter wobble on the acid line. Slow (0.25-1) = gentle sweeps. Fast (4-8) = rapid wah-wah. Syncs musically around 1, 2, or 4.">
          <label>RATE</label>
          <input type="range" id="acid-rate" min="0.25" max="8" value="2" step="0.25">
          <span class="val" id="al-val">2.0</span>
        </div>
        <div class="si" title="Reverb wet/dry mix on lead and pad. 0 = completely dry. 1 = fully washed out in reverb. 0.2-0.5 is the sweet spot for spacey leads.">
          <label>VERB</label>
          <input type="range" id="reverb" min="0" max="1" value="0.35" step="0.01">
          <span class="val" id="rv-val">0.35</span>
        </div>
        <div class="si" title="Ping-pong delay mix on lead and acid. 0 = no delay. Higher = more echoes bouncing left-right. Above 0.5 gets washy. Good for spacey trails at 0.2-0.4.">
          <label>DLY</label>
          <input type="range" id="delay" min="0" max="0.8" value="0.3" step="0.01">
          <span class="val" id="dl-val">0.30</span>
        </div>
        <div class="si" title="Master distortion/overdrive. 0 = clean signal. Even small amounts (0.05-0.15) add grit. Above 0.5 gets aggressive and crunchy. Applied to everything through the master bus.">
          <label>DIST</label>
          <input type="range" id="distortion" min="0" max="1" value="0" step="0.01">
          <span class="val" id="ds-val">0</span>
        </div>
        <div class="si" title="Kick drum pitch sweep speed â€” how fast the kick drops from high to low. Short (0.01-0.05) = tight, punchy click. Long (0.1-0.2) = boomy, pitched-down thud. Very sensitive â€” small changes reshape the kick character.">
          <label>KICK</label>
          <input type="range" id="kick-punch" min="0.01" max="0.2" value="0.05" step="0.005">
          <span class="val" id="kp-val">0.05</span>
        </div>
        <div class="si" style="justify-content:flex-end; gap:4px;">
          <div class="loop-btns">
            <button class="btn" data-bars="1">1</button>
            <button class="btn active" data-bars="2">2</button>
            <button class="btn" data-bars="3">3</button>
            <button class="btn" data-bars="4">4</button>
          </div>
          <span style="font-size:9px;color:#8070a0;">bars</span>
          <button class="btn active" id="kaleido-toggle" style="margin-left:4px; font-size:9px;">KAL</button>
        </div>
      </div>
    </div>
  </div>

  <!-- step sequencer -->
  <div class="collapse-section">
    <div class="divider"></div>
    <div class="collapse-header" data-collapse="seq-body">
      <span class="collapse-arrow open">&#9654;</span>
      <span class="section-title" style="margin:0;">STEP SEQUENCER</span>
      <select id="seq-root" style="font-size:9px; background:#1a1230; color:#c0b0e0; border:1px solid #302050; border-radius:3px; padding:1px 2px;" onclick="event.stopPropagation()"></select>
      <select id="seq-scale" style="font-size:9px; background:#1a1230; color:#c0b0e0; border:1px solid #302050; border-radius:3px; padding:1px 2px;" onclick="event.stopPropagation()"></select>
    </div>
    <div class="collapse-body open" id="seq-body">
      <div class="seq-header" style="margin-top:2px;">
        <div class="bar-tabs" id="bar-tabs"></div>
        <button class="btn" id="clear-bar" style="font-size:9px;">CLR</button>
        <button class="btn" id="save-map" style="font-size:9px;">SAVE</button>
        <button class="btn" id="export-wav" style="font-size:9px;">WAV</button>
      </div>
      <div id="genre-presets" style="display:flex; flex-wrap:wrap; gap:2px; margin:2px 0;"></div>
      <div id="seq-styles" style="display:flex; flex-wrap:wrap; gap:3px; margin:2px 0; align-items:center;"></div>
      <div id="seq-nums" class="seq-nums"></div>
      <div id="sequencer"></div>

      <!-- progress -->
      <div class="progress-wrap">
        <div class="progress-bar" id="loop-bar"></div>
        <span class="progress-label" id="loop-pos"></span>
      </div>

      <!-- song arranger -->
      <div style="display:flex; align-items:center; gap:6px; margin:4px 0 2px;">
        <span class="section-title">ARRANGER</span>
        <button class="btn" id="arr-mode" style="font-size:8px; padding:1px 6px;">LOOP</button>
        <button class="btn" id="arr-add" style="font-size:8px; padding:1px 6px;">+ BAR</button>
        <button class="btn" id="arr-copy" style="font-size:8px; padding:1px 6px;" title="Copy current bar to end of arrangement">COPY</button>
        <button class="btn" id="arr-bridge" style="font-size:8px; padding:1px 6px;" title="Generate a bridge/transition bar">BRIDGE</button>
        <button class="btn" id="arr-clear" style="font-size:8px; padding:1px 6px;">CLR</button>
      </div>
      <div id="arr-track" class="arr-track"></div>

      <div id="maps-list" style="max-height:80px; overflow-y:auto; margin:2px 0;"></div>
    </div>
  </div>

  <!-- textures -->
  <div class="collapse-section">
    <div class="divider"></div>
    <div class="collapse-header" data-collapse="tex-body">
      <span class="collapse-arrow">&#9654;</span>
      <span class="section-title" style="margin:0;">TEXTURES</span>
    </div>
    <div class="collapse-body" id="tex-body">
      <div class="tex-row">
        <input type="text" id="tex-prompt" placeholder="texture style...">
        <button class="btn" id="tex-gen">GENERATE</button>
      </div>
      <div class="presets">
        <button class="btn" data-p="abstract geometric patterns, neon gradients">neon</button>
        <button class="btn" data-p="dark organic tendrils, bioluminescent">organic</button>
        <button class="btn" data-p="fractal mandelbrot zoom, electric">fractal</button>
        <button class="btn" data-p="cyberpunk circuitry, glitch art">cyber</button>
      </div>
      <div class="tex-row" style="gap:6px;">
        <button class="btn" id="tex-tunnel">Tunnel</button>
        <button class="btn" id="tex-geo">Geometry</button>
        <button class="btn" id="tex-clear">Clear</button>
      </div>
      <div class="gallery" id="gallery"></div>
    </div>
  </div>

  <!-- ACE-Step audio generator -->
  <div class="collapse-section">
    <div class="divider"></div>
    <div class="collapse-header" data-collapse="ace-body">
      <span class="collapse-arrow open">&#9654;</span>
      <span class="ace-dot off" id="ace-dot"></span>
      <span class="section-title" style="margin:0;">SAMPLE GENERATOR</span>
      <span class="ace-dot off" id="llm-dot" title="LLM Tag Generator" style="margin-left:4px;"></span>
    </div>
    <div class="collapse-body open" id="ace-body">
      <div class="tex-row">
        <input type="text" id="ace-prompt" placeholder="describe the sound to generate...">
        <button class="btn" id="ace-gen">GENERATE</button>
      </div>

      <!-- dynamic tag cascade (LLM-powered) -->
      <div id="tag-cascade" style="margin:3px 0;">
        <div id="tag-breadcrumb" style="display:flex; align-items:center; gap:3px; margin:2px 0; flex-wrap:wrap;"></div>
        <div id="tag-loading" style="display:none; font-size:8px; color:#8070a0; margin:3px 0;"><span class="tag-spinner"></span> Loading tags...</div>
        <div id="tag-grid"></div>
      </div>
      <button class="btn" id="ace-clear-tags" style="font-size:8px; padding:1px 6px; margin-bottom:3px;">CLEAR PROMPT</button>

      <!-- vocal / instrumental toggle + lyrics -->
      <div style="display:flex; align-items:center; gap:6px; margin:3px 0;">
        <button class="btn active" id="ace-inst-toggle" style="font-size:9px;">INSTRUMENTAL</button>
        <button class="btn" id="ace-vox-toggle" style="font-size:9px;">VOCAL</button>
      </div>
      <textarea id="ace-lyrics" placeholder="lyrics / vocal content..." style="display:none; width:100%; height:48px; resize:vertical; padding:4px 8px; border-radius:4px; border:1px solid rgba(180,0,255,0.3); background:rgba(20,0,40,0.6); color:#d0b0ff; font-family:inherit; font-size:10px; outline:none; margin:2px 0;"></textarea>

      <!-- duration + quality sliders -->
      <div style="display:flex; align-items:center; gap:6px; margin:3px 0;" title="Duration of the generated audio. ACE-Step minimum is 10s internally â€” shorter clips are trimmed after generation.">
        <label style="font-size:9px;color:#8070a0;width:28px;">DUR</label>
        <input type="range" id="ace-dur" min="1" max="240" value="120" step="1" style="flex:1;">
        <span class="val" id="ace-dur-val" style="width:30px;">120s</span>
      </div>
      <div style="display:flex; align-items:center; gap:6px; margin:3px 0;" title="Inference steps â€” higher = better quality but slower. 4=fast/rough, 8=default, 16=high, 32=best. Each doubling roughly doubles generation time.">
        <label style="font-size:9px;color:#8070a0;width:28px;">QUAL</label>
        <input type="range" id="ace-steps" min="4" max="32" value="32" step="4" style="flex:1;">
        <span class="val" id="ace-steps-val" style="width:30px;">32</span>
      </div>
      <div style="display:flex; align-items:center; gap:6px; margin:3px 0;" title="Guidance scale (CFG) â€” only effective for SFT/Base models. Turbo (8 steps) ignores this. For SFT: 3-7 = creative, 7-15 = balanced, 15+ = strict.">
        <label style="font-size:9px;color:#8070a0;width:28px;">CFG</label>
        <input type="range" id="ace-cfg" min="1" max="25" value="17.5" step="0.5" style="flex:1;">
        <span class="val" id="ace-cfg-val" style="width:30px;">17.5</span>
      </div>
      <div style="display:flex; align-items:center; gap:6px; margin:3px 0;" title="LM Temperature â€” controls creativity of the language model planner. Lower = conservative/deterministic. Higher = creative/surprising. Default: 0.85.">
        <label style="font-size:9px;color:#8070a0;width:28px;">TEMP</label>
        <input type="range" id="ace-lm-temp" min="0.1" max="1.5" value="0.85" step="0.05" style="flex:1;">
        <span class="val" id="ace-lm-temp-val" style="width:30px;">0.85</span>
      </div>
      <div style="display:flex; align-items:center; gap:6px; margin:3px 0;" title="Seed â€” fixed seed for reproducible results. Set to -1 for random. Use a fixed seed to compare prompt changes without random variation.">
        <label style="font-size:9px;color:#8070a0;width:28px;">SEED</label>
        <input type="number" id="ace-seed" value="-1" min="-1" max="2147483647" style="flex:1; padding:2px 6px; border-radius:4px; border:1px solid rgba(180,0,255,0.3); background:rgba(20,0,40,0.6); color:#d0b0ff; font-family:inherit; font-size:10px; outline:none; width:60px;">
        <button class="btn" id="ace-seed-rand" style="font-size:8px; padding:1px 6px;" title="Randomize seed">ðŸŽ²</button>
      </div>
      <div style="display:flex; align-items:center; margin-top:4px;">
        <span class="section-title">SAMPLE BANK</span>
        <button class="btn" id="open-library" style="font-size:8px; padding:1px 6px; margin-left:auto;">LIBRARY</button>
      </div>
      <div id="sample-bank" class="sample-bank"></div>
    </div>
  </div>

  <!-- sample mixer -->
  <div class="collapse-section">
    <div class="collapse-header" data-collapse="mixer-body" style="margin-top:4px;">
      <span class="collapse-arrow">&#9654;</span>
      <span class="section-title" style="margin:0;">SAMPLE MIXER</span>
    </div>
    <div class="collapse-body" id="mixer-body">
      <div id="sample-mixer"></div>
    </div>
  </div>

  <!-- lora studio -->
  <div class="lora-section">
    <div class="divider"></div>
    <div class="lora-header" id="lora-toggle">
      <span class="lora-arrow" id="lora-arrow">&#9654;</span>
      <span class="lora-dot" id="lora-dot"></span>
      <span class="section-title" style="margin:0;">LORA STUDIO</span>
    </div>
    <div class="lora-body" id="lora-body">
      <!-- Status bar -->
      <div style="display:flex; align-items:center; gap:8px; margin:4px 0;">
        <span style="font-size:9px; color:#8070a0;" id="lora-status-label">No adapter loaded</span>
        <div style="margin-left:auto; display:flex; align-items:center; gap:4px;">
          <label style="font-size:8px; color:#605080;">SCALE</label>
          <input type="range" id="lora-scale" min="0" max="200" value="100" step="1" style="width:60px;" disabled>
          <span class="val" id="lora-scale-val" style="width:28px; font-size:9px;">1.0</span>
        </div>
      </div>
      <!-- Load / Unload / Toggle -->
      <div style="display:flex; gap:4px; align-items:center; margin:3px 0;">
        <input type="text" class="lora-input" id="lora-path" placeholder="Adapter path or click from list...">
        <button class="btn" id="lora-load" style="font-size:8px; padding:2px 6px;">LOAD</button>
        <button class="btn" id="lora-unload" style="font-size:8px; padding:2px 6px;" disabled>UNLOAD</button>
        <button class="btn" id="lora-onoff" style="font-size:8px; padding:2px 6px;" disabled>ON</button>
      </div>
      <!-- Adapter browser -->
      <div style="display:flex; align-items:center; gap:4px; margin:4px 0;">
        <span style="font-size:8px; color:#605080;">ADAPTERS</span>
        <button class="btn" id="lora-refresh" style="font-size:7px; padding:1px 5px;">REFRESH</button>
      </div>
      <div class="lora-adapters" id="lora-adapter-list"></div>
      <!-- Training divider -->
      <div class="divider"></div>
      <span style="font-size:8px; color:#605080; letter-spacing:1px;">TRAINING</span>
      <!-- Preprocess row -->
      <div style="display:flex; gap:4px; align-items:center; margin:3px 0;">
        <input type="text" class="lora-input" id="lora-audio-dir" placeholder="Audio directory to preprocess...">
        <button class="btn" id="lora-preprocess" style="font-size:8px; padding:2px 6px;">PREPROCESS</button>
      </div>
      <!-- Tensor dir (auto-filled or manual) -->
      <div style="display:flex; gap:4px; align-items:center; margin:3px 0;">
        <input type="text" class="lora-input" id="lora-tensor-dir" placeholder="Tensor directory (auto-filled after preprocess)...">
      </div>
      <!-- Params grid -->
      <div class="slider-grid" style="margin:4px 0;">
        <div class="si">
          <label>RANK</label>
          <input type="range" id="lora-rank" min="1" max="64" value="8" step="1">
          <span class="val" id="lora-rank-val">8</span>
        </div>
        <div class="si">
          <label>ALPHA</label>
          <input type="range" id="lora-alpha" min="1" max="128" value="16" step="1">
          <span class="val" id="lora-alpha-val">16</span>
        </div>
        <div class="si">
          <label>EPOCHS</label>
          <input type="range" id="lora-epochs" min="1" max="500" value="100" step="1">
          <span class="val" id="lora-epochs-val">100</span>
        </div>
        <div class="si">
          <label>LR</label>
          <input type="range" id="lora-lr" min="-6" max="-2" value="-4" step="0.1">
          <span class="val" id="lora-lr-val">1e-4</span>
        </div>
      </div>
      <!-- Train / Stop -->
      <div style="display:flex; gap:4px; align-items:center; margin:3px 0;">
        <button class="btn" id="lora-train" style="font-size:9px; padding:3px 10px;">START TRAINING</button>
        <button class="btn" id="lora-stop" style="font-size:9px; padding:3px 10px;" disabled>STOP</button>
      </div>
      <!-- Progress -->
      <div class="lora-progress-wrap"><div class="lora-progress-bar" id="lora-progress"></div></div>
      <div class="lora-status-text" id="lora-train-status"></div>
    </div>
  </div>

  <!-- settings -->
  <div class="settings" id="settings-panel">
    <div class="divider"></div>
    <div class="settings-row">
      <label style="font-size:9px;color:#8070a0;">API KEY</label>
      <input type="text" id="api-key" placeholder="Google API key">
      <button class="btn" id="save-key" style="font-size:9px;">Save</button>
    </div>
    <div class="settings-row">
      <label style="font-size:9px;color:#8070a0;">ACE-STEP</label>
      <input type="text" id="ace-url" placeholder="ACE-Step API base" value="/ace-api">
      <button class="btn" id="ace-check" style="font-size:9px;">Check</button>
    </div>
  </div>
  <div class="status" id="status"></div>
</div>

<!-- clip editor modal -->
<div id="clip-modal" class="modal-overlay" style="display:none;">
  <div class="modal-content" style="width:min(600px,90vw);">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
      <span class="section-title" id="clip-title">CLIP EDITOR</span>
      <button class="btn" id="clip-close" style="font-size:13px;">&times;</button>
    </div>
    <canvas id="clip-canvas" style="width:100%; height:120px; background:rgba(20,0,40,0.5); border-radius:6px; border:1px solid rgba(255,255,255,0.08);"></canvas>
    <div style="display:flex; gap:6px; align-items:center; margin:6px 0;">
      <label style="font-size:9px;color:#8070a0;width:36px;">START</label>
      <input type="range" id="clip-start" min="0" max="1000" value="0" step="1" style="flex:1;">
      <span class="val" id="clip-start-val" style="width:40px;">0.00s</span>
    </div>
    <div style="display:flex; gap:6px; align-items:center; margin:6px 0;">
      <label style="font-size:9px;color:#8070a0;width:36px;">END</label>
      <input type="range" id="clip-end" min="0" max="1000" value="1000" step="1" style="flex:1;">
      <span class="val" id="clip-end-val" style="width:40px;">10.0s</span>
    </div>
    <div style="font-size:9px; color:#8070a0;" id="clip-info">Trimmed: 10.0s</div>
    <div style="display:flex; gap:6px; margin-top:10px;">
      <button class="btn" id="clip-preview">&#9654; PREVIEW</button>
      <button class="btn" id="clip-save">SAVE CLIP</button>
      <button class="btn" id="clip-replace">REPLACE</button>
    </div>
  </div>
</div>

<!-- library modal -->
<div id="lib-modal" class="modal-overlay" style="display:none;">
  <div class="modal-content" style="width:min(640px,92vw); max-height:80vh;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
      <span class="section-title">SAMPLE LIBRARY</span>
      <button class="btn" id="lib-close" style="font-size:13px;">&times;</button>
    </div>
    <div id="lib-list" style="max-height:calc(80vh - 60px); overflow-y:auto;"></div>
  </div>
</div>

<!-- prompt preview modal -->
<div id="prompt-modal" class="modal-overlay" style="display:none;">
  <div class="modal-content" style="width:min(560px,90vw);">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
      <span class="section-title">REVIEW PROMPT</span>
      <button class="btn" id="prompt-modal-close" style="font-size:13px;">&times;</button>
    </div>
    <div style="font-size:8px; color:#605080; margin-bottom:4px;">Edit the prompt before sending to ACE-Step:</div>
    <textarea id="prompt-modal-text" style="width:100%; height:80px; resize:vertical; padding:6px 8px; border-radius:4px; border:1px solid rgba(180,0,255,0.3); background:rgba(20,0,40,0.6); color:#d0b0ff; font-family:inherit; font-size:11px; outline:none;"></textarea>
    <div style="display:flex; gap:8px; align-items:center; margin-top:6px;">
      <label style="font-size:8px; color:#605080;">LYRICS</label>
      <span id="prompt-modal-vocal" style="font-size:8px; color:#8070a0;"></span>
    </div>
    <textarea id="prompt-modal-lyrics" style="width:100%; height:48px; resize:vertical; padding:4px 8px; border-radius:4px; border:1px solid rgba(180,0,255,0.3); background:rgba(20,0,40,0.6); color:#d0b0ff; font-family:inherit; font-size:10px; outline:none; margin:2px 0;"></textarea>
    <div style="display:flex; gap:6px; align-items:center; margin-top:4px; font-size:8px; color:#605080;">
      <span id="prompt-modal-info"></span>
    </div>
    <div style="display:flex; gap:6px; margin-top:10px; justify-content:flex-end;">
      <button class="btn" id="prompt-modal-cancel">CANCEL</button>
      <button class="btn" id="prompt-modal-send" style="background:rgba(0,180,80,0.3); border-color:rgba(0,255,120,0.4); color:#88ffaa;">SEND TO ACE-STEP</button>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MAIN MODULE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script type="module">
import { LoopSynth, SEQ_INSTRUMENTS, SEQ_LABELS, SEQ_COLORS, SAMPLE_SLOTS, SCALES, ROOTS, BASS_STYLES, LEAD_STYLES, HAT_STYLES, KICK_STYLES, CLAP_STYLES, PERC_STYLES, STAB_STYLES, GENRE_PRESETS } from './synth.js';

const SLOT_COLORS = ['#ff8800','#88ff00','#0088ff','#ff0088'];
const SCALE_DISPLAY = { major:'Major', minor:'Minor', dorian:'Dorian', phrygian:'Phrygian', lydian:'Lydian', mixolydian:'Mixolydian', harmonicMinor:'Harmonic Minor', hungarianMin:'Hungarian Minor', locrian:'Locrian', pentatonicMaj:'Pentatonic Maj', pentatonicMin:'Pentatonic Min', blues:'Blues', wholeTone:'Whole Tone', chromatic:'Chromatic' };
import { ReactiveVisualizer } from './visualizer.js';
import { ImagenAPI } from './api.js';
import { SampleBank } from './samples.js';

const container = document.getElementById('canvas-container');
const vis   = new ReactiveVisualizer(container);
const synth = new LoopSynth();
const storedKey = localStorage.getItem('loop_api_key') || '';
const api   = new ImagenAPI(storedKey);
const sbank = new SampleBank('/ace-api');

/* â”€â”€ panel drag â”€â”€ */
{
  const panel = document.getElementById('panel');
  const drag  = document.getElementById('panel-drag');
  let dragging = false, ox = 0, oy = 0;

  drag.addEventListener('pointerdown', e => {
    if (e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
    dragging = true;
    ox = e.clientX - panel.offsetLeft;
    oy = e.clientY - panel.offsetTop;
    drag.setPointerCapture(e.pointerId);
    e.preventDefault();
  });

  drag.addEventListener('pointermove', e => {
    if (!dragging) return;
    const x = Math.max(0, Math.min(window.innerWidth - 60, e.clientX - ox));
    const y = Math.max(0, Math.min(window.innerHeight - 40, e.clientY - oy));
    panel.style.left = x + 'px';
    panel.style.top  = y + 'px';
  });

  drag.addEventListener('pointerup', () => { dragging = false; });
  drag.addEventListener('lostpointercapture', () => { dragging = false; });
}

// Beat map persistence
class MapStore {
  constructor() { this.dbName = 'loop_maps'; this.storeName = 'maps'; this.db = null; }
  async open() {
    if (this.db) return;
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(this.dbName, 1);
      req.onupgradeneeded = () => req.result.createObjectStore(this.storeName, { keyPath: 'id', autoIncrement: true });
      req.onsuccess = () => { this.db = req.result; resolve(); };
      req.onerror = () => reject(req.error);
    });
  }
  async save(entry) {
    await this.open();
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(this.storeName, 'readwrite');
      const req = tx.objectStore(this.storeName).add(entry);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  async getAll() {
    await this.open();
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(this.storeName, 'readonly');
      const req = tx.objectStore(this.storeName).getAll();
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  async remove(id) {
    await this.open();
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(this.storeName, 'readwrite');
      const req = tx.objectStore(this.storeName).delete(id);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }
}
const mapStore = new MapStore();

const $ = id => document.getElementById(id);
const playBtn=$('play-btn'), randBtn=$('rand-btn');
const bpmSlider=$('bpm'), intSlider=$('intensity'), fltSlider=$('filter');
const bpmVal=$('bpm-val'), intVal=$('int-val'), fltVal=$('flt-val');
const loopBar=$('loop-bar'), loopPos=$('loop-pos');
const texPrompt=$('tex-prompt'), texGen=$('tex-gen'), gallery=$('gallery'), status=$('status');
const apiKeyIn=$('api-key'), kalToggle=$('kaleido-toggle');
const settingsToggle=$('settings-toggle'), settingsPanel=$('settings-panel');

apiKeyIn.value = storedKey;

/* â”€â”€ auto-load API key from .env â”€â”€ */
try {
  const envRes = await fetch('.env');
  if (envRes.ok) {
    const envText = await envRes.text();
    const m = envText.match(/GOOGLE_API_KEY=(.+)/);
    if (m) {
      const k = m[1].trim();
      api.setApiKey(k);
      apiKeyIn.value = k;
      if (!storedKey) localStorage.setItem('loop_api_key', k);
      status.textContent = 'API key loaded from .env';
      setTimeout(() => { if (status.textContent.includes('.env')) status.textContent = ''; }, 2500);
    }
  }
} catch (_) {}

let texMode = 'tunnel';
let seqBar  = 0;           // which bar the sequencer is showing
let seqStepEls = [];        // flat array of step DOM elements for fast update
let prevHighlight = -1;

/* â”€â”€ root / scale / style controls â”€â”€ */
const seqRoot = $('seq-root'), seqScale = $('seq-scale');
ROOTS.forEach(r => { const o = document.createElement('option'); o.value=r; o.textContent=r; seqRoot.appendChild(o); });
Object.keys(SCALES).forEach(s => { const o = document.createElement('option'); o.value=s; o.textContent=SCALE_DISPLAY[s]||s; seqScale.appendChild(o); });
seqRoot.value = synth.root;
seqScale.value = synth.scale;
seqRoot.addEventListener('change', () => { synth.root = seqRoot.value; synth._rebuildSequence(); buildSequencer(); });
seqScale.addEventListener('change', () => { synth.scale = seqScale.value; synth._rebuildSequence(); buildSequencer(); });

/* â”€â”€ genre preset buttons â”€â”€ */
const genreBar = $('genre-presets');
Object.keys(GENRE_PRESETS).forEach(g => {
  const btn = document.createElement('button');
  btn.className = 'btn';
  btn.style.cssText = 'font-size:8px; padding:1px 5px;';
  btn.textContent = g.toUpperCase();
  btn.addEventListener('click', async () => {
    await synth.init();
    const r = synth.randomizeGenre(g);
    $('bpm').value = synth.bpm; $('bpm-val').textContent = synth.bpm;
    seqRoot.value = synth.root; seqScale.value = synth.scale;
    updateStyleSelects();
    buildSequencer();
    status.textContent = `${g}: ${r.root} ${SCALE_DISPLAY[r.scale]||r.scale} ${r.bpm}bpm`;
    setTimeout(() => { if (status.textContent.startsWith(g)) status.textContent=''; }, 3500);
  });
  genreBar.appendChild(btn);
});

/* â”€â”€ per-instrument style selectors â”€â”€ */
const STYLE_MAP = { kick: KICK_STYLES, bass: BASS_STYLES, hat: HAT_STYLES, lead: LEAD_STYLES, clap: CLAP_STYLES, perc: PERC_STYLES, stab: STAB_STYLES };
const STYLE_PROP = { kick:'kickStyle', bass:'bassStyle', hat:'hatStyle', lead:'leadStyle', clap:'clapStyle', perc:'percStyle', stab:'stabStyle' };
const styleSelects = {};

function buildStyleSelects() {
  const wrap = $('seq-styles');
  wrap.innerHTML = '';
  for (const inst of ['kick','bass','hat','clap','lead','perc','stab']) {
    const sel = document.createElement('select');
    sel.style.cssText = 'font-size:8px; background:#1a1230; color:#c0b0e0; border:1px solid #302050; border-radius:3px; padding:1px 2px;';
    const label = inst.slice(0,3).toUpperCase();
    STYLE_MAP[inst].forEach(s => { const o = document.createElement('option'); o.value=s; o.textContent=`${label}:${s}`; sel.appendChild(o); });
    sel.value = synth[STYLE_PROP[inst]];
    sel.addEventListener('change', () => {
      synth[STYLE_PROP[inst]] = sel.value;
      synth.generatePatterns();
      buildSequencer();
    });
    styleSelects[inst] = sel;
    wrap.appendChild(sel);
  }
}
buildStyleSelects();

function updateStyleSelects() {
  for (const inst of Object.keys(styleSelects)) {
    styleSelects[inst].value = synth[STYLE_PROP[inst]];
  }
}

/* â”€â”€ transport â”€â”€ */
playBtn.addEventListener('click', async () => {
  await synth.init();
  if (synth.isPlaying) { synth.stop(); playBtn.innerHTML='&#9654; PLAY'; }
  else { synth.start(); playBtn.innerHTML='&#9632; STOP'; }
});

/* â”€â”€ main sliders â”€â”€ */
function wire(id, display, fn, fmt) {
  const el = $(id), valEl = $(display);
  el.addEventListener('input', () => { const v=+el.value; valEl.textContent=fmt?fmt(v):v; fn(v); });
}
wire('bpm',       'bpm-val', v => { if (synth.initialized) synth.setBPM(v); });
wire('intensity', 'int-val', v => synth.setIntensity(v), v=>v.toFixed(2));
wire('filter',    'flt-val', v => { if (synth.initialized) synth.setFilterCutoff(v); }, v=>v>=10000?(v/1000).toFixed(1)+'k':v);
wire('swing',     'swg-val', v => { if (synth.initialized) synth.setSwing(v); }, v=>v.toFixed(2));

/* â”€â”€ sound design sliders â”€â”€ */
wire('bass-decay',  'bd-val', v => { if (synth.initialized) synth.setBassDecay(v); },  v=>v.toFixed(2));
wire('acid-reso',   'ar-val', v => { if (synth.initialized) synth.setAcidResonance(v); }, v=>v.toFixed(1));
wire('acid-rate',   'al-val', v => { if (synth.initialized) synth.setAcidLFORate(v); },  v=>v.toFixed(2));
wire('reverb',      'rv-val', v => { if (synth.initialized) synth.setReverbMix(v); },    v=>v.toFixed(2));
wire('delay',       'dl-val', v => { if (synth.initialized) synth.setDelayMix(v); },     v=>v.toFixed(2));
wire('distortion',  'ds-val', v => { if (synth.initialized) synth.setDistortion(v); },   v=>v.toFixed(2));
wire('kick-punch',  'kp-val', v => { if (synth.initialized) synth.setKickPunch(v); },    v=>v.toFixed(3));

/* â”€â”€ loop length (preserves existing patterns) â”€â”€ */
document.querySelectorAll('[data-bars]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('[data-bars]').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    const bars = +btn.dataset.bars;
    synth.setLoopLength(bars);
    if (seqBar >= bars) seqBar = bars - 1;
    buildSequencer();
  });
});

/* â”€â”€ clear current bar â”€â”€ */
$('clear-bar').addEventListener('click', () => {
  synth.clearBar(seqBar);
  buildSequencer();
});

/* â”€â”€ randomize â”€â”€ */
randBtn.addEventListener('click', async () => {
  await synth.init();
  const r = synth.randomize();
  seqRoot.value = synth.root; seqScale.value = synth.scale;
  $('bpm').value = synth.bpm; $('bpm-val').textContent = synth.bpm;
  updateStyleSelects();
  buildSequencer();
  status.textContent = `${r.root} ${SCALE_DISPLAY[r.scale]||r.scale} | kick:${r.kick} bass:${r.bass} lead:${r.lead} hats:${r.hats} clap:${r.clap}`;
  setTimeout(() => { if (status.textContent.includes(r.root)) status.textContent=''; }, 3500);
});

/* â”€â”€ kaleidoscope â”€â”€ */
kalToggle.addEventListener('click', () => { kalToggle.classList.toggle('active'); vis.setKaleidoscope(kalToggle.classList.contains('active')); });

/* â”€â”€ settings â”€â”€ */
settingsToggle.addEventListener('click', () => settingsPanel.classList.toggle('open'));
$('save-key').addEventListener('click', () => {
  const k=apiKeyIn.value.trim(); api.setApiKey(k); localStorage.setItem('loop_api_key',k);
  status.textContent='API key saved'; setTimeout(()=>{if(status.textContent==='API key saved')status.textContent='';},2000);
});

/* â”€â”€ texture mode â”€â”€ */
$('tex-tunnel').addEventListener('click', () => { texMode='tunnel'; status.textContent='mode: tunnel'; });
$('tex-geo').addEventListener('click', () => { texMode='geometry'; status.textContent='mode: geometry'; });
$('tex-clear').addEventListener('click', () => { vis.clearTexture(); status.textContent='textures cleared'; });

/* â”€â”€ texture generation â”€â”€ */
async function generateTexture(prompt) {
  if (api.busy) return;
  status.textContent='generating texture...'; texGen.disabled=true;
  try { const url=await api.generateTexture(prompt); vis.applyTexture(url,texMode); addGalleryThumb(url,api.galleryCount-1); status.textContent='texture applied!'; }
  catch(e) { status.textContent='error: '+e.message; }
  finally { texGen.disabled=false; }
}
texGen.addEventListener('click', () => generateTexture(texPrompt.value.trim()));
texPrompt.addEventListener('keydown', e => { if (e.key==='Enter') generateTexture(texPrompt.value.trim()); });
document.querySelectorAll('[data-p]').forEach(btn => {
  btn.addEventListener('click', () => { texPrompt.value=btn.dataset.p; generateTexture(btn.dataset.p); });
});

function addGalleryThumb(dataUrl, idx) {
  const img=document.createElement('img'); img.src=dataUrl; img.title=`Texture ${idx+1}`;
  img.addEventListener('click', () => { gallery.querySelectorAll('img').forEach(i=>i.classList.remove('sel')); img.classList.add('sel'); vis.applyTexture(dataUrl,texMode); });
  gallery.appendChild(img);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ACE-STEP SAMPLE GENERATOR â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

const aceDot   = $('ace-dot');
const aceGen   = $('ace-gen');
const acePrompt = $('ace-prompt');
const aceDur   = $('ace-dur');
const aceDurVal = $('ace-dur-val');
const aceSteps = $('ace-steps');
const aceStepsVal = $('ace-steps-val');
const aceCfg = $('ace-cfg');
const aceCfgVal = $('ace-cfg-val');
const aceLmTemp = $('ace-lm-temp');
const aceLmTempVal = $('ace-lm-temp-val');
const aceSeed = $('ace-seed');
const aceLyrics = $('ace-lyrics');
const sampleBankEl = $('sample-bank');

let aceInstrumental = true;
let previewSource = null;   // currently playing BufferSourceNode
let previewBtn   = null;    // the button element that triggered it

// duration slider
aceDur.addEventListener('input', () => { aceDurVal.textContent = aceDur.value + 's'; });

// quality slider
aceSteps.addEventListener('input', () => { aceStepsVal.textContent = aceSteps.value; });

// guidance scale slider
aceCfg.addEventListener('input', () => { aceCfgVal.textContent = aceCfg.value; });

// LM temperature slider
aceLmTemp.addEventListener('input', () => { aceLmTempVal.textContent = aceLmTemp.value; });

// seed controls
$('ace-seed-rand').addEventListener('click', (e) => {
  e.stopPropagation();
  aceSeed.value = Math.floor(Math.random() * 2147483647);
});

// instrumental / vocal toggle
$('ace-inst-toggle').addEventListener('click', () => {
  aceInstrumental = true;
  $('ace-inst-toggle').classList.add('active');
  $('ace-vox-toggle').classList.remove('active');
  aceLyrics.style.display = 'none';
});
$('ace-vox-toggle').addEventListener('click', () => {
  aceInstrumental = false;
  $('ace-vox-toggle').classList.add('active');
  $('ace-inst-toggle').classList.remove('active');
  aceLyrics.style.display = '';
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LLM TAG CASCADE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

const LLM_API = '/llm-api';
const llmDot = $('llm-dot');
const tagGrid = $('tag-grid');
const tagBreadcrumb = $('tag-breadcrumb');
const tagLoading = $('tag-loading');

const GENRE_SEEDS = [
  'Techno', 'House', 'Trance', 'Drum & Bass', 'Hip Hop', 'Ambient',
  'Pop', 'Rock', 'Jazz', 'Classical', 'Metal', 'World Music'
];

const FALLBACK_TAGS = {
  SUBGENRE: ['deep house', 'techno', 'progressive', 'minimal', 'breakbeat', 'synthwave'],
  INST: ['synthesizer', 'drum machine', 'bass synth', 'hi-hat', 'synth pad', 'electric piano', 'sampler'],
  MOOD: ['energetic', 'deep', 'euphoric', 'dark', 'uplifting', 'hypnotic'],
  CHAR: ['driving rhythm', 'rolling bassline', 'layered textures', 'dynamic builds', 'tight groove'],
  TIMBRE: ['warm', 'bright', 'punchy', 'crisp'],
  ERA: ['90s rave', 'modern', 'retro'],
  PROD: ['studio-polished', 'heavily layered', 'raw energy'],
  REGION: ['berlin', 'detroit', 'london', 'ibiza', 'tokyo']
};

const tagState = {
  path: [],
  selected: {},
  cache: new Map(),
  llmOnline: false,
  llmModel: null,
  lastAutoPrompt: '',
  customSuffix: '',
};

async function checkLLM() {
  try {
    const r = await fetch(`${LLM_API}/v1/models`, { signal: AbortSignal.timeout(5000) });
    if (r.ok) {
      const data = await r.json();
      tagState.llmModel = data.data?.[0]?.id || null;
      tagState.llmOnline = true;
    } else {
      tagState.llmOnline = false;
    }
  } catch { tagState.llmOnline = false; }
  llmDot.classList.toggle('on', tagState.llmOnline);
  llmDot.classList.toggle('off', !tagState.llmOnline);
}

const TAG_SYSTEM_PROMPT = `You are a music production expert writing captions for an AI music generation model (ACE-Step). Given a genre path and optionally selected tags, output ONLY a valid JSON object with these 8 arrays. Tags should be DESCRIPTIVE and SPECIFIC â€” they'll be used directly as the model's caption input.

- SUBGENRE: 6 specific subgenres or style variations (use established names)
- INST: 7 specific instruments, synths, drum machines, or sound design elements (be precise: "detuned supersaw lead" not just "synth")
- MOOD: 6 emotional/atmospheric qualities (combine adjective + context: "dark brooding tension" not just "dark")
- CHAR: 5 sonic/production characteristics describing the sound (e.g. "rolling 16th-note bassline", "sidechain-pumped pads", "staccato acid stabs")
- TIMBRE: 4 texture/tonal descriptors (e.g. "warm analog saturation", "crisp digital highs", "punchy compressed drums")
- ERA: 3 era or stylistic references with context (e.g. "90s warehouse rave", "modern festival sound")
- PROD: 3 production style descriptions (e.g. "heavily layered with stereo width", "raw and unpolished energy", "studio-polished clarity")
- REGION: 5 cities, countries, or scenes central to this style

All tags lowercase, 2-5 words for maximum descriptiveness. Use authentic genre terminology. When selected tags are provided, tailor ALL remaining categories to complement that specific combination â€” be cohesive, not generic.

Examples:

Input: goa trance
{"SUBGENRE":["nitzhonot","dark goa","old school goa","full-on goa","psybient","suomi"],"INST":["303 acid bass line","analog kick drum","modular synth lead","delay feedback textures","atmospheric pad layers","fx riser sweeps","rhythmic sequencer patterns"],"MOOD":["euphoric transcendence","mystical journey","dark psychedelic tension","hypnotic trance state","blissful release","cosmic wonder"],"CHAR":["spiraling melodic sequences","acid squelch filter sweeps","layered psychedelic fx","long atmospheric builds","driving four-on-floor kick"],"TIMBRE":["bright cutting leads","metallic resonant filters","airy reverb tails","sharp transient attacks"],"ERA":["90s goa beach parties","early 2000s peak era","retro analog revival"],"PROD":["densely layered textures","heavy fx processing","studio-polished clarity"],"REGION":["goa india","israel","japan","london","sweden"]}

Input: jazz
{"SUBGENRE":["bebop","cool jazz","free jazz","fusion","hard bop","modal jazz"],"INST":["tenor saxophone","muted trumpet","upright acoustic bass","grand piano chords","brushed drum kit","vibraphone mallets","hollow body guitar"],"MOOD":["soulful late-night intimacy","introspective contemplation","playful rhythmic interplay","melancholic blue notes","uplifting swing energy","deep contemplative mood"],"CHAR":["improvised melodic runs","swing shuffle rhythm","rich extended harmony","call and response phrases","dynamic volume expression"],"TIMBRE":["warm round bass tones","smooth breathy saxophone","mellow piano resonance","crisp cymbal shimmer"],"ERA":["50s golden age bebop","60s modal exploration","modern jazz fusion"],"PROD":["live room recording","analog tape warmth","intimate close-mic setup"],"REGION":["new york","chicago","new orleans","paris","tokyo"]}`;

function buildTagCacheKey() {
  const parts = [tagState.path.join(' > ')];
  for (const [cat, set] of Object.entries(tagState.selected)) {
    if (set.size) parts.push(`${cat}:${[...set].sort().join(',')}`);
  }
  return parts.join('|');
}

function buildTagUserPrompt() {
  let prompt = tagState.path.join(' > ');
  const selParts = [];
  for (const [cat, set] of Object.entries(tagState.selected)) {
    if (set.size) selParts.push(`${cat.toLowerCase()}: ${[...set].join(', ')}`);
  }
  if (selParts.length) prompt += ' [selected: ' + selParts.join('; ') + ']';
  return prompt;
}

async function llmGenerateTags() {
  const key = buildTagCacheKey();
  if (tagState.cache.has(key)) return tagState.cache.get(key);

  const res = await fetch(`${LLM_API}/v1/chat/completions`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      model: tagState.llmModel || 'default',
      messages: [
        { role: 'system', content: TAG_SYSTEM_PROMPT },
        { role: 'user', content: buildTagUserPrompt() }
      ],
      temperature: 0.6,
      max_tokens: 400,
    }),
  });

  if (!res.ok) throw new Error(`LLM ${res.status}`);
  const data = await res.json();
  let content = data.choices?.[0]?.message?.content || '';

  // strip <think>...</think> tags if present
  content = content.replace(/<think>[\s\S]*?<\/think>/g, '').trim();

  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (!jsonMatch) throw new Error('Invalid LLM response');
  const tags = JSON.parse(jsonMatch[0]);

  tagState.cache.set(key, tags);
  return tags;
}

function renderGenreRow() {
  const row = document.createElement('div');
  row.style.cssText = 'display:flex; flex-wrap:wrap; gap:2px; margin:2px 0;';
  const label = document.createElement('span');
  label.style.cssText = 'font-size:7px;color:#605080;width:32px;line-height:20px;';
  label.textContent = 'GENRE';
  row.appendChild(label);

  GENRE_SEEDS.forEach(genre => {
    const chip = document.createElement('button');
    const g = genre.toLowerCase();
    chip.className = 'btn tag-chip subgenre';
    chip.textContent = g;
    if (tagState.path.includes(g)) chip.classList.add('selected');
    chip.addEventListener('click', e => {
      e.stopPropagation();
      const idx = tagState.path.indexOf(g);
      if (idx >= 0) { tagState.path.splice(idx, 1); }
      else { tagState.path.push(g); }
      drillDown();
    });
    row.appendChild(chip);
  });

  tagGrid.appendChild(row);
}

function renderGenreSeeds() {
  tagGrid.innerHTML = '';
  renderGenreRow();
}

let tagRefreshId = 0; // debounce concurrent LLM calls

async function drillDown() {
  renderBreadcrumb();

  // no genres selected â€” just show genre seeds
  if (!tagState.path.length) {
    renderGenreSeeds();
    rebuildPromptFromTags();
    return;
  }

  tagLoading.style.display = '';
  const myId = ++tagRefreshId;

  try {
    let tags;
    if (tagState.llmOnline) {
      tags = await llmGenerateTags();
    } else {
      tags = FALLBACK_TAGS;
    }
    if (myId !== tagRefreshId) return; // stale response
    renderCascadeTags(tags);
  } catch (e) {
    console.warn('LLM tag generation failed:', e);
    if (myId === tagRefreshId) renderCascadeTags(FALLBACK_TAGS);
  } finally {
    if (myId === tagRefreshId) tagLoading.style.display = 'none';
  }
}

function renderCascadeTags(data) {
  tagGrid.innerHTML = '';
  // always show genre seeds row at top
  renderGenreRow();
  const categories = ['SUBGENRE', 'INST', 'MOOD', 'CHAR', 'TIMBRE', 'ERA', 'PROD', 'REGION'];
  const catLabels = { SUBGENRE: 'SUB', INST: 'INST', MOOD: 'MOOD', CHAR: 'CHAR', TIMBRE: 'TONE', ERA: 'ERA', PROD: 'PROD', REGION: 'REG' };

  categories.forEach(cat => {
    const items = data[cat] || [];
    if (!items.length) return;

    const row = document.createElement('div');
    row.style.cssText = 'display:flex; flex-wrap:wrap; gap:2px; margin:2px 0;';
    const label = document.createElement('span');
    label.style.cssText = 'font-size:7px;color:#605080;width:32px;line-height:20px;';
    label.textContent = catLabels[cat] || cat;
    row.appendChild(label);

    items.forEach(tag => {
      const tagText = (typeof tag === 'string' ? tag : String(tag)).toLowerCase();
      const chip = document.createElement('button');
      chip.className = 'btn tag-chip' + (cat === 'SUBGENRE' ? ' subgenre' : '');
      chip.textContent = tagText;

      if (tagState.selected[cat]?.has(tagText)) chip.classList.add('selected');

      chip.addEventListener('click', e => {
        e.stopPropagation();
        if (!tagState.selected[cat]) tagState.selected[cat] = new Set();
        const set = tagState.selected[cat];
        if (set.has(tagText)) { set.delete(tagText); }
        else { set.add(tagText); }
        rebuildPromptFromTags();
        drillDown();
      });

      row.appendChild(chip);
    });

    tagGrid.appendChild(row);
  });

  rebuildPromptFromTags();
}

function renderBreadcrumb() {
  tagBreadcrumb.innerHTML = '';

  const root = document.createElement('span');
  root.className = 'tag-breadcrumb-item';
  root.textContent = 'ALL';
  root.addEventListener('click', e => {
    e.stopPropagation();
    tagState.path = [];
    renderGenreSeeds();
    renderBreadcrumb();
    rebuildPromptFromTags();
  });
  tagBreadcrumb.appendChild(root);

  tagState.path.forEach((seg, i) => {
    const sep = document.createElement('span');
    sep.className = 'tag-breadcrumb-sep';
    sep.textContent = ' \u203A ';
    tagBreadcrumb.appendChild(sep);

    const item = document.createElement('span');
    item.className = 'tag-breadcrumb-item';
    item.textContent = seg;
    if (i < tagState.path.length - 1) {
      item.addEventListener('click', e => {
        e.stopPropagation();
        tagState.path = tagState.path.slice(0, i + 1);
        drillDown();
      });
    } else {
      item.classList.add('current');
    }
    tagBreadcrumb.appendChild(item);
  });
}

// Track user's manual typing in the prompt field
// (programmatic .value= does NOT fire 'input', so this only catches real typing)
acePrompt.addEventListener('input', () => {
  const current = acePrompt.value;
  const auto = tagState.lastAutoPrompt || '';
  if (auto && current.startsWith(auto)) {
    tagState.customSuffix = current.slice(auto.length);
  } else if (!auto) {
    tagState.customSuffix = current;
  }
  // if user edited the auto portion itself, keep customSuffix unchanged
});

function rebuildPromptFromTags() {
  // Build a structured caption per ACE-Step tutorial best practices.
  // Group tags by dimension so the LM CoT rewrite gets clear input.
  const genreParts = [...tagState.path];
  const dimOrder = ['SUBGENRE','MOOD','INST','TIMBRE','CHAR','ERA','PROD','REGION'];
  const dimParts = [];
  for (const cat of dimOrder) {
    const set = tagState.selected[cat];
    if (set?.size) dimParts.push([...set].join(', '));
  }
  const allParts = [...genreParts, ...dimParts];
  const newAuto = allParts.length ? allParts.join(', ') : '';

  // combine auto tags + whatever user typed manually
  let result = newAuto;
  const suffix = (tagState.customSuffix || '').replace(/^[,\s]+/, '');
  if (suffix) {
    result = newAuto ? newAuto + ', ' + suffix : suffix;
  }

  acePrompt.value = result;
  tagState.lastAutoPrompt = newAuto;
}

// Build rich instrumental lyrics with structure tags per ACE-Step tutorial.
// Tells the model HOW the track should unfold over time â€” not just "[Instrumental]".
function buildInstrumentalLyrics() {
  const dur = +aceDur.value;
  const moods = tagState.selected.MOOD ? [...tagState.selected.MOOD] : [];
  const chars = tagState.selected.CHAR ? [...tagState.selected.CHAR] : [];
  const insts = tagState.selected.INST ? [...tagState.selected.INST] : [];

  // short clips: minimal but still structured
  if (dur <= 15) {
    const mood = moods[0] || 'energetic';
    return `[Instrumental - ${mood}]`;
  }

  // medium clips (15-60s): intro + main + outro
  if (dur <= 60) {
    const introMood = moods[0] || 'ambient';
    const mainMood = moods[1] || chars[0] || 'energetic';
    return `[Intro - ${introMood}]\n\n[Main Theme - ${mainMood}]\n\n[Outro - fade out]`;
  }

  // longer tracks: full structure with builds and drops
  const parts = [];
  parts.push(`[Intro - atmospheric]`);
  parts.push('');
  parts.push(`[Build - rising energy]`);
  parts.push('');
  parts.push(`[Drop - ${moods[0] || 'powerful'}]`);
  parts.push('');
  if (dur > 120) {
    parts.push(`[Breakdown - ${moods[1] || 'atmospheric'}]`);
    parts.push('');
    parts.push(`[Build - rising energy]`);
    parts.push('');
    parts.push(`[Drop - ${moods[0] || 'explosive'}]`);
    parts.push('');
  }
  if (dur > 180) {
    parts.push(`[Bridge - ${insts[0] || 'melodic'}]`);
    parts.push('');
    parts.push(`[Drop - ${chars[0] || 'high energy'}]`);
    parts.push('');
  }
  parts.push(`[Outro - fade out]`);
  return parts.join('\n');
}

// initial render
renderGenreSeeds();
checkLLM();

// clear prompt + reset cascade
$('ace-clear-tags').addEventListener('click', () => {
  acePrompt.value = '';
  tagState.path = [];
  tagState.selected = {};
  tagState.lastAutoPrompt = '';
  tagState.customSuffix = '';
  renderGenreSeeds();
  tagBreadcrumb.innerHTML = '';
});

// download a sample as a WAV file
function downloadSample(sample) {
  const url = URL.createObjectURL(sample.audioBlob);
  const a = document.createElement('a');
  a.href = url;
  a.download = (sample.name || 'sample').replace(/[^a-zA-Z0-9_\- ]/g, '') + '.wav';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}

// stop any playing preview
function stopPreview() {
  if (previewSource) {
    try { previewSource.stop(); } catch (_) {}
    previewSource = null;
  }
  if (previewBtn) {
    previewBtn.classList.remove('previewing');
    previewBtn.textContent = '\u25B6';
    previewBtn = null;
  }
}

// progress callback
sbank.onProgress = msg => { status.textContent = msg; };

// check ACE-Step connection on load
(async () => {
  const ok = await sbank.checkConnection();
  aceDot.classList.toggle('on', ok);
  aceDot.classList.toggle('off', !ok);
})();

// settings: check connection button
$('ace-check').addEventListener('click', async () => {
  const base = $('ace-url').value.trim() || '/ace-api';
  sbank.apiBase = base;
  status.textContent = 'Checking ACE-Step...';
  const ok = await sbank.checkConnection();
  aceDot.classList.toggle('on', ok);
  aceDot.classList.toggle('off', !ok);
  status.textContent = ok ? 'ACE-Step connected!' : 'ACE-Step not reachable';
  setTimeout(() => { if (status.textContent.includes('ACE-Step')) status.textContent = ''; }, 2500);
});

// generate sample
async function generateAceSample(prompt) {
  if (sbank.busy) return;
  aceGen.disabled = true;
  const seedVal = +aceSeed.value;
  try {
    await sbank.generateSample({
      prompt,
      lyrics: aceLyrics.value.trim() || (aceInstrumental ? buildInstrumentalLyrics() : '[Instrumental]'),
      duration: +aceDur.value,
      instrumental: aceInstrumental,
      inferenceSteps: +aceSteps.value,
      guidanceScale: +aceCfg.value,
      bpm: synth.bpm,
      keyscale: synth.root + ' ' + (SCALE_DISPLAY[synth.scale] || 'Minor'),
      seed: seedVal >= 0 ? seedVal : undefined,
      lmTemperature: +aceLmTemp.value,
    });
    rebuildSampleBank();
    status.textContent = 'Sample generated!';
  } catch (e) {
    status.textContent = 'ACE-Step error: ' + e.message;
  } finally {
    aceGen.disabled = false;
  }
}

// prompt preview modal
function openPromptPreview() {
  const prompt = acePrompt.value.trim();
  if (!prompt) { status.textContent = 'Enter a prompt first'; return; }
  // caption should NOT contain BPM/key â€” those go as metadata params
  $('prompt-modal-text').value = prompt;
  // show auto-generated instrumental lyrics or user lyrics
  if (aceInstrumental) {
    $('prompt-modal-vocal').textContent = '(instrumental â€” structure tags auto-generated, editable)';
    // use user's saved lyrics if they previously edited, else auto-generate
    const saved = aceLyrics.value.trim();
    $('prompt-modal-lyrics').value = saved || buildInstrumentalLyrics();
    $('prompt-modal-lyrics').style.display = '';
  } else {
    $('prompt-modal-vocal').textContent = '(vocal mode)';
    $('prompt-modal-lyrics').value = aceLyrics.value.trim();
    $('prompt-modal-lyrics').style.display = '';
  }
  const keyscale = synth.root + ' ' + (SCALE_DISPLAY[synth.scale] || 'Minor');
  const seedDisp = +aceSeed.value >= 0 ? aceSeed.value : 'random';
  $('prompt-modal-info').textContent = `Duration: ${aceDur.value}s | Steps: ${aceSteps.value} | Temp: ${aceLmTemp.value} | BPM: ${synth.bpm} | Key: ${keyscale} | Seed: ${seedDisp}`;
  $('prompt-modal').style.display = '';
  $('prompt-modal-text').focus();
}

$('prompt-modal-close').addEventListener('click', () => { $('prompt-modal').style.display = 'none'; });
$('prompt-modal-cancel').addEventListener('click', () => { $('prompt-modal').style.display = 'none'; });
$('prompt-modal').addEventListener('click', e => { if (e.target === $('prompt-modal')) $('prompt-modal').style.display = 'none'; });

$('prompt-modal-send').addEventListener('click', () => {
  const finalPrompt = $('prompt-modal-text').value.trim();
  if (!finalPrompt) return;
  // update main prompt + lyrics from modal edits (both vocal and instrumental)
  acePrompt.value = finalPrompt;
  aceLyrics.value = $('prompt-modal-lyrics').value;
  $('prompt-modal').style.display = 'none';
  generateAceSample(finalPrompt);
});

aceGen.addEventListener('click', () => openPromptPreview());
acePrompt.addEventListener('keydown', e => { if (e.key === 'Enter') openPromptPreview(); });

// decode audio blob â†’ AudioBuffer for Tone.js
async function decodeBlob(blob) {
  const ctx = Tone.context?.rawContext || new AudioContext();
  const buf = await blob.arrayBuffer();
  return ctx.decodeAudioData(buf);
}

// assign sample to a synth slot (0-3)
async function assignToSlot(sampleIndex, slot) {
  const sample = sbank.getSample(sampleIndex);
  if (!sample) return;
  try {
    status.textContent = `Loading sample to S${slot + 1}...`;
    const audioBuf = await decodeBlob(sample.audioBlob);
    synth.loadSampleToSlot(slot, audioBuf, sample.name);
    rebuildSampleBank();
    buildMixer();
    status.textContent = `S${slot + 1}: ${sample.name}`;
  } catch (e) {
    status.textContent = 'Load error: ' + e.message;
  }
}

// build sample bank UI
function rebuildSampleBank() {
  sampleBankEl.innerHTML = '';
  sbank.samples.forEach((sample, idx) => {
    const item = document.createElement('div');
    item.className = 'sample-item';

    const name = document.createElement('span');
    name.className = 's-name';
    name.textContent = sample.name;
    name.title = 'Click to rename';
    name.style.cursor = 'pointer';
    name.addEventListener('click', e => {
      e.stopPropagation();
      const oldName = sample.name;
      const input = document.createElement('input');
      input.type = 'text';
      input.value = oldName;
      input.style.cssText = 'width:100%;background:rgba(20,0,40,0.8);border:1px solid #c060ff;color:#d0b0ff;font-family:inherit;font-size:9px;padding:1px 4px;border-radius:2px;outline:none;';
      let done = false;
      const finish = async () => {
        if (done) return;
        done = true;
        const newName = input.value.trim() || oldName;
        if (newName !== oldName) {
          for (let s = 0; s < SAMPLE_SLOTS; s++) {
            if (synth.sampleNames[s] === oldName) synth.sampleNames[s] = newName;
          }
          await sbank.renameSample(idx, newName);
          buildMixer();
        }
        rebuildSampleBank();
      };
      input.addEventListener('blur', finish);
      input.addEventListener('keydown', ev => {
        if (ev.key === 'Enter') input.blur();
        if (ev.key === 'Escape') { input.value = oldName; input.blur(); }
      });
      name.replaceWith(input);
      input.focus();
      input.select();
    });

    const dur = document.createElement('span');
    dur.className = 's-dur';
    dur.textContent = sample.duration + 's';

    item.appendChild(name);
    item.appendChild(dur);

    // slot assignment buttons S1-S4
    for (let s = 0; s < SAMPLE_SLOTS; s++) {
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.textContent = 'S' + (s + 1);
      const loaded = synth.sampleNames[s] === sample.name;
      if (loaded) btn.classList.add('active');
      btn.style.color = SLOT_COLORS[s];
      btn.addEventListener('click', e => { e.stopPropagation(); assignToSlot(idx, s); });
      item.appendChild(btn);
    }

    // preview play/stop button
    const play = document.createElement('button');
    play.className = 'btn';
    play.textContent = '\u25B6';
    play.addEventListener('click', async e => {
      e.stopPropagation();
      // if this button is already playing, stop it
      if (previewBtn === play) {
        stopPreview();
        return;
      }
      // stop any other preview first
      stopPreview();
      try {
        const audioBuf = await decodeBlob(sample.audioBlob);
        const ctx = Tone.context?.rawContext || new AudioContext();
        const src = ctx.createBufferSource();
        src.buffer = audioBuf;
        src.connect(ctx.destination);
        src.onended = () => {
          if (previewBtn === play) stopPreview();
        };
        src.start();
        previewSource = src;
        previewBtn = play;
        play.classList.add('previewing');
        play.textContent = '\u25A0';
      } catch (_) {}
    });
    item.appendChild(play);

    // edit/trim button
    const edit = document.createElement('button');
    edit.className = 'btn';
    edit.textContent = '\u2702';
    edit.title = 'Edit / Trim';
    edit.addEventListener('click', e => {
      e.stopPropagation();
      openClipEditor(idx);
    });
    item.appendChild(edit);

    // download button
    const dl = document.createElement('button');
    dl.className = 'btn';
    dl.textContent = '\u2193';
    dl.title = 'Download WAV';
    dl.addEventListener('click', e => { e.stopPropagation(); downloadSample(sample); });
    item.appendChild(dl);

    // delete button
    const del = document.createElement('button');
    del.className = 'btn';
    del.textContent = '\u00D7';
    del.addEventListener('click', async e => {
      e.stopPropagation();
      await sbank.deleteSample(idx);
      rebuildSampleBank();
    });
    item.appendChild(del);

    sampleBankEl.appendChild(item);
  });

}

// build sample mixer UI
function buildMixer() {
  const mixerEl = $('sample-mixer');
  mixerEl.innerHTML = '';

  let anyLoaded = false;
  for (let s = 0; s < SAMPLE_SLOTS; s++) {
    const name = synth.sampleNames[s];
    if (!name) continue;
    anyLoaded = true;

    const row = document.createElement('div');
    row.className = 'mix-row';

    // slot label
    const label = document.createElement('span');
    label.className = 'mix-label';
    label.textContent = 'S' + (s + 1);
    label.style.color = SLOT_COLORS[s];
    row.appendChild(label);

    // sample name
    const nameEl = document.createElement('span');
    nameEl.className = 'mix-name';
    nameEl.textContent = name;
    nameEl.title = name;
    row.appendChild(nameEl);

    // volume slider
    const vol = document.createElement('input');
    vol.type = 'range';
    vol.min = -40;
    vol.max = 6;
    vol.step = 1;
    vol.value = synth.samplePlayers[s]?.volume?.value ?? -6;
    row.appendChild(vol);

    // dB display
    const dbLabel = document.createElement('span');
    dbLabel.className = 'mix-db';
    dbLabel.textContent = Math.round(+vol.value) + 'dB';
    row.appendChild(dbLabel);

    vol.addEventListener('input', () => {
      const db = +vol.value;
      dbLabel.textContent = Math.round(db) + 'dB';
      synth.setSampleVolume(s, db);
    });
    vol.addEventListener('mousedown', e => e.stopPropagation());

    // mute button
    const mute = document.createElement('button');
    mute.className = 'btn';
    mute.textContent = 'M';
    if (synth.samplePlayers[s]?.mute) mute.classList.add('muted');
    mute.addEventListener('click', e => {
      e.stopPropagation();
      const isMuted = !mute.classList.contains('muted');
      mute.classList.toggle('muted', isMuted);
      synth.setSampleMute(s, isMuted);
    });
    row.appendChild(mute);

    // loop toggle
    const loop = document.createElement('button');
    loop.className = 'btn';
    loop.textContent = 'LP';
    if (synth.samplePlayers[s]?.loop !== false) loop.classList.add('active');
    loop.addEventListener('click', e => {
      e.stopPropagation();
      const isLoop = !loop.classList.contains('active');
      loop.classList.toggle('active', isLoop);
      synth.setSampleLoop(s, isLoop);
    });
    row.appendChild(loop);

    // clear slot button
    const clr = document.createElement('button');
    clr.className = 'btn';
    clr.textContent = '\u00D7';
    clr.addEventListener('click', e => {
      e.stopPropagation();
      synth.clearSampleSlot(s);
      rebuildSampleBank();
      buildMixer();
    });
    row.appendChild(clr);

    mixerEl.appendChild(row);
  }

  if (!anyLoaded) {
    const empty = document.createElement('div');
    empty.className = 'mix-empty';
    empty.textContent = 'Assign samples from the bank above using S1-S4 buttons';
    mixerEl.appendChild(empty);
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• STEP SEQUENCER â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

function buildSequencer() {
  const seqContainer = $('sequencer');
  const numsContainer = $('seq-nums');
  const tabsContainer = $('bar-tabs');
  seqContainer.innerHTML = '';
  numsContainer.innerHTML = '';
  tabsContainer.innerHTML = '';
  seqStepEls = [];

  // bar tabs
  for (let b = 0; b < synth.loopLength; b++) {
    const tab = document.createElement('button');
    tab.className = 'btn' + (b === seqBar ? ' active' : '');
    tab.textContent = b + 1;
    tab.addEventListener('click', () => { seqBar = b; buildSequencer(); });
    tabsContainer.appendChild(tab);
  }

  // step numbers
  for (let c = 0; c < 16; c++) {
    const sp = document.createElement('span');
    sp.textContent = c + 1;
    if (c % 4 === 0) sp.className = 'beat-num';
    numsContainer.appendChild(sp);
  }

  const HIT_ALPHA = ['', '70', 'a0', 'd0'];

  // instrument rows
  SEQ_INSTRUMENTS.forEach((inst, row) => {
    const rowDiv = document.createElement('div');
    rowDiv.className = 'seq-row';

    // apply current inst state
    const curState = synth.getInstState(inst);
    if (curState === 'mute') rowDiv.classList.add('muted');
    if (curState === 'force') rowDiv.classList.add('forced');

    const label = document.createElement('span');
    label.className = 'seq-label';
    label.textContent = SEQ_LABELS[row];
    label.style.color = curState === 'mute' ? '#ff4444' : curState === 'force' ? '#44ff44' : SEQ_COLORS[row];
    label.title = 'Click to cycle: normal â†’ force â†’ mute';
    label.addEventListener('click', e => {
      e.stopPropagation();
      const state = synth.cycleInstState(inst);
      rowDiv.classList.remove('muted', 'forced');
      if (state === 'mute') { rowDiv.classList.add('muted'); label.style.color = '#ff4444'; }
      else if (state === 'force') { rowDiv.classList.add('forced'); label.style.color = '#44ff44'; }
      else { label.style.color = SEQ_COLORS[row]; }
    });
    rowDiv.appendChild(label);

    for (let col = 0; col < 16; col++) {
      const step = seqBar * 16 + col;
      const btn = document.createElement('div');
      btn.className = 'seq-step';
      if (col % 4 === 0) btn.classList.add('beat-start');

      const pat = synth.patterns[inst];
      const isOn = pat && pat[step] != null;
      if (isOn) {
        const hits = synth.getHits(inst, step);
        btn.classList.add('on');
        btn.style.background = SEQ_COLORS[row] + (HIT_ALPHA[hits] || '70');
        if (hits > 1) btn.textContent = hits;
      }

      btn.addEventListener('mousedown', e => {
        e.stopPropagation();
        const result = synth.toggleStep(inst, step);
        if (result) {
          btn.classList.add('on');
          btn.style.background = SEQ_COLORS[row] + (HIT_ALPHA[result.hits] || '70');
          btn.textContent = result.hits > 1 ? result.hits : '';
        } else {
          btn.classList.remove('on');
          btn.style.background = '';
          btn.textContent = '';
        }
      });

      rowDiv.appendChild(btn);
      seqStepEls.push({ el: btn, step, inst, row });
    }

    seqContainer.appendChild(rowDiv);
  });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• BEAT MAPS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

function rebuildMapsList(maps) {
  const el = $('maps-list');
  el.innerHTML = '';
  if (!maps.length) return;
  maps.sort((a, b) => b.ts - a.ts);
  for (const map of maps) {
    const row = document.createElement('div');
    row.className = 'map-item';

    const name = document.createElement('span');
    name.className = 'm-name';
    name.textContent = map.name;

    const info = document.createElement('span');
    info.className = 'm-info';
    info.textContent = `${map.state.bpm}bpm ${map.state.root} ${map.state.scale}`;

    const load = document.createElement('button');
    load.className = 'btn';
    load.textContent = 'LOAD';
    load.addEventListener('click', e => {
      e.stopPropagation();
      synth.loadState(map.state);
      $('bpm').value = synth.bpm;
      $('bpm-val').textContent = synth.bpm;
      seqRoot.value = synth.root; seqScale.value = synth.scale;
      updateStyleSelects();
      document.querySelectorAll('[data-bars]').forEach(b => b.classList.toggle('active', +b.dataset.bars === synth.loopLength));
      if (seqBar >= synth.loopLength) seqBar = synth.loopLength - 1;
      buildSequencer();
      status.textContent = `Loaded: ${map.name}`;
      setTimeout(() => { if (status.textContent.includes('Loaded')) status.textContent = ''; }, 2500);
    });

    const del = document.createElement('button');
    del.className = 'btn';
    del.textContent = '\u00D7';
    del.addEventListener('click', async e => {
      e.stopPropagation();
      await mapStore.remove(map.id);
      const updated = await mapStore.getAll();
      rebuildMapsList(updated);
    });

    row.appendChild(name);
    row.appendChild(info);
    row.appendChild(load);
    row.appendChild(del);
    el.appendChild(row);
  }
}

$('save-map').addEventListener('click', async () => {
  const name = prompt('Beat map name:', `${synth.root} ${synth.scale} ${synth.bpm}bpm`);
  if (!name) return;
  const entry = { name, state: synth.getState(), ts: Date.now() };
  await mapStore.save(entry);
  const maps = await mapStore.getAll();
  rebuildMapsList(maps);
  status.textContent = `Saved: ${name}`;
  setTimeout(() => { if (status.textContent.includes('Saved')) status.textContent = ''; }, 2500);
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• WAV EXPORT â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

$('export-wav').addEventListener('click', async () => {
  await synth.init();
  const exportBtn = $('export-wav');
  if (exportBtn.dataset.recording) return;

  // calculate loop duration
  const barSec = (60 / synth.bpm) * 4;
  const totalBars = (synth.songMode && synth.arrangement.length) ? synth.arrangement.length : synth.loopLength;
  const loopSec = barSec * totalBars;

  // set up recorder on master output
  const recorder = new Tone.Recorder();
  synth.masterGain.connect(recorder);

  // ensure transport is playing
  const wasPlaying = synth.isPlaying;
  if (!wasPlaying) {
    synth.start();
    playBtn.innerHTML = '&#9632; STOP';
  }

  exportBtn.dataset.recording = '1';
  exportBtn.textContent = 'REC...';
  exportBtn.style.color = '#ff4444';
  status.textContent = `Recording ${loopSec.toFixed(1)}s loop...`;

  recorder.start();

  await new Promise(r => setTimeout(r, loopSec * 1000 + 200));

  const webmBlob = await recorder.stop();
  synth.masterGain.disconnect(recorder);
  recorder.dispose();

  // stop if we started it
  if (!wasPlaying) {
    synth.stop();
    playBtn.innerHTML = '&#9654; PLAY';
  }

  // decode webm â†’ AudioBuffer â†’ WAV
  status.textContent = 'Encoding WAV...';
  try {
    const ctx = new AudioContext();
    const arrayBuf = await webmBlob.arrayBuffer();
    const audioBuf = await ctx.decodeAudioData(arrayBuf);
    ctx.close();

    // encode to 16-bit PCM WAV
    const sr = audioBuf.sampleRate, ch = audioBuf.numberOfChannels, len = audioBuf.length;
    const dataSize = len * ch * 2;
    const ab = new ArrayBuffer(44 + dataSize);
    const v = new DataView(ab);
    const w = (o, s) => { for (let i = 0; i < s.length; i++) v.setUint8(o + i, s.charCodeAt(i)); };
    w(0,'RIFF'); v.setUint32(4, 36 + dataSize, true); w(8,'WAVE');
    w(12,'fmt '); v.setUint32(16,16,true); v.setUint16(20,1,true);
    v.setUint16(22, ch, true); v.setUint32(24, sr, true);
    v.setUint32(28, sr * ch * 2, true); v.setUint16(32, ch * 2, true);
    v.setUint16(34, 16, true); w(36,'data'); v.setUint32(40, dataSize, true);
    const chData = [];
    for (let c = 0; c < ch; c++) chData.push(audioBuf.getChannelData(c));
    let off = 44;
    for (let i = 0; i < len; i++) {
      for (let c = 0; c < ch; c++) {
        const s = Math.max(-1, Math.min(1, chData[c][i]));
        v.setInt16(off, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        off += 2;
      }
    }
    const wavBlob = new Blob([ab], { type: 'audio/wav' });

    // trigger download
    const url = URL.createObjectURL(wavBlob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `loop_${synth.root}_${synth.scale}_${synth.bpm}bpm.wav`;
    a.click();
    URL.revokeObjectURL(url);
    status.textContent = `Exported ${loopSec.toFixed(1)}s WAV`;
  } catch (e) {
    status.textContent = 'Export failed: ' + e.message;
  }

  exportBtn.textContent = 'WAV';
  exportBtn.style.color = '';
  delete exportBtn.dataset.recording;
  setTimeout(() => { if (status.textContent.includes('Exported') || status.textContent.includes('failed')) status.textContent = ''; }, 3500);
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SONG ARRANGER â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

const arrTrack = $('arr-track');
const arrModeBtn = $('arr-mode');

function buildArranger() {
  arrTrack.innerHTML = '';
  arrModeBtn.textContent = synth.songMode ? 'SONG' : 'LOOP';
  arrModeBtn.classList.toggle('active', synth.songMode);

  if (!synth.arrangement.length) {
    arrTrack.innerHTML = '<span style="font-size:8px;color:#504070;">Add bars to build a song arrangement</span>';
    return;
  }

  synth.arrangement.forEach((barIdx, arrIdx) => {
    const block = document.createElement('div');
    block.className = 'arr-block';
    // Mark bridge bars (stored as negative indices: -1 = bridge after bar 0)
    if (barIdx < 0) {
      block.classList.add('bridge');
      block.textContent = 'BR';
      block.title = 'Bridge / transition';
    } else {
      block.textContent = barIdx + 1;
      block.title = `Bar ${barIdx + 1} â€” click to view`;
    }

    block.addEventListener('click', e => {
      if (e.target.classList.contains('arr-x')) return;
      if (barIdx >= 0 && barIdx < synth.loopLength) {
        seqBar = barIdx;
        buildSequencer();
      }
    });

    // remove button
    const x = document.createElement('span');
    x.className = 'arr-x';
    x.textContent = '\u00D7';
    x.addEventListener('click', e => {
      e.stopPropagation();
      synth.arrangement.splice(arrIdx, 1);
      if (synth.songMode) synth._rebuildSequence();
      buildArranger();
    });
    block.appendChild(x);

    arrTrack.appendChild(block);
  });
}

// mode toggle
arrModeBtn.addEventListener('click', () => {
  synth.songMode = !synth.songMode;
  synth._rebuildSequence();
  buildArranger();
});

// add current bar to arrangement
$('arr-add').addEventListener('click', () => {
  synth.arrangement.push(seqBar);
  if (synth.songMode) synth._rebuildSequence();
  buildArranger();
});

// copy current bar to a new bar at end of pattern, then add to arrangement
$('arr-copy').addEventListener('click', () => {
  const newBar = synth.loopLength;
  synth.setLoopLength(newBar + 1);
  synth.copyBar(seqBar, newBar);
  synth.arrangement.push(newBar);
  // update bar buttons
  document.querySelectorAll('[data-bars]').forEach(b => b.classList.remove('active'));
  if (synth.songMode) synth._rebuildSequence();
  buildSequencer();
  buildArranger();
  status.textContent = `Copied bar ${seqBar + 1} â†’ bar ${newBar + 1}`;
});

// generate bridge
$('arr-bridge').addEventListener('click', () => {
  // show a quick picker for bridge type
  const types = ['buildup', 'breakdown', 'fill', 'drop'];
  const labels = ['BUILD-UP', 'BREAKDOWN', 'FILL', 'DROP'];
  const overlay = document.createElement('div');
  overlay.className = 'modal-overlay';
  overlay.style.cssText = 'z-index:250;';
  const box = document.createElement('div');
  box.className = 'modal-content';
  box.style.cssText = 'width:min(300px,80vw); text-align:center;';
  box.innerHTML = '<div class="section-title" style="margin-bottom:8px;">BRIDGE TYPE</div>';
  types.forEach((t, i) => {
    const btn = document.createElement('button');
    btn.className = 'btn';
    btn.style.cssText = 'margin:3px; min-width:80px;';
    btn.textContent = labels[i];
    btn.addEventListener('click', () => {
      document.body.removeChild(overlay);
      const barIdx = synth.generateBridge(t);
      synth.arrangement.push(barIdx);
      if (synth.songMode) synth._rebuildSequence();
      buildSequencer();
      buildArranger();
      status.textContent = `Added ${labels[i]} bridge (bar ${barIdx + 1})`;
    });
    box.appendChild(btn);
  });
  const cancel = document.createElement('button');
  cancel.className = 'btn';
  cancel.style.cssText = 'margin:8px 3px 0; font-size:9px;';
  cancel.textContent = 'CANCEL';
  cancel.addEventListener('click', () => document.body.removeChild(overlay));
  box.appendChild(document.createElement('br'));
  box.appendChild(cancel);
  overlay.appendChild(box);
  overlay.addEventListener('click', e => { if (e.target === overlay) document.body.removeChild(overlay); });
  document.body.appendChild(overlay);
});

// clear arrangement
$('arr-clear').addEventListener('click', () => {
  synth.arrangement = [];
  if (synth.songMode) synth._rebuildSequence();
  buildArranger();
});

// arrangement position callback â€” highlight current block
synth.onArrangementPos = (arrIdx) => {
  arrTrack.querySelectorAll('.arr-block').forEach((b, i) => {
    b.classList.toggle('active', i === arrIdx);
  });
};

buildArranger();

// initial build (uses default patterns from constructor)
synth.generatePatterns();
buildSequencer();
buildMixer();

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CLIP EDITOR â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

let clipSampleIdx = -1;
let clipAudioBuf = null;
let clipPreviewSrc = null;

function openClipEditor(idx) {
  clipSampleIdx = idx;
  const sample = sbank.getSample(idx);
  if (!sample) return;
  $('clip-title').textContent = sample.name;
  stopClipPreview();

  decodeBlob(sample.audioBlob).then(buf => {
    clipAudioBuf = buf;
    const dur = buf.duration;
    $('clip-start').value = 0;
    $('clip-end').value = 1000;
    $('clip-start-val').textContent = '0.00s';
    $('clip-end-val').textContent = dur.toFixed(2) + 's';
    $('clip-info').textContent = `Trimmed: ${dur.toFixed(2)}s (original: ${dur.toFixed(2)}s)`;
    $('clip-modal').style.display = '';
    requestAnimationFrame(() => drawClipWaveform());
  });
}

function drawClipWaveform() {
  if (!clipAudioBuf) return;
  const canvas = $('clip-canvas');
  const dpr = window.devicePixelRatio || 1;
  const w = canvas.offsetWidth;
  const h = canvas.offsetHeight;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  const data = clipAudioBuf.getChannelData(0);
  const startFrac = +$('clip-start').value / 1000;
  const endFrac = +$('clip-end').value / 1000;

  // background
  ctx.fillStyle = 'rgba(20,0,40,0.5)';
  ctx.fillRect(0, 0, w, h);

  // waveform
  const step = Math.ceil(data.length / w);
  ctx.beginPath();
  ctx.strokeStyle = '#c060ff';
  ctx.lineWidth = 1;
  for (let x = 0; x < w; x++) {
    const baseIdx = Math.floor(x / w * data.length);
    let min = 1, max = -1;
    for (let j = 0; j < step && baseIdx + j < data.length; j++) {
      const val = data[baseIdx + j];
      if (val < min) min = val;
      if (val > max) max = val;
    }
    ctx.moveTo(x, (1 - max) * h / 2);
    ctx.lineTo(x, (1 - min) * h / 2);
  }
  ctx.stroke();

  // dim outside trim region
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillRect(0, 0, startFrac * w, h);
  ctx.fillRect(endFrac * w, 0, (1 - endFrac) * w, h);

  // trim markers
  ctx.strokeStyle = '#00ffff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(startFrac * w, 0); ctx.lineTo(startFrac * w, h);
  ctx.moveTo(endFrac * w, 0); ctx.lineTo(endFrac * w, h);
  ctx.stroke();

  // time labels on markers
  const dur = clipAudioBuf.duration;
  ctx.fillStyle = '#00ffff';
  ctx.font = '9px monospace';
  ctx.fillText((startFrac * dur).toFixed(2) + 's', startFrac * w + 3, 11);
  ctx.textAlign = 'right';
  ctx.fillText((endFrac * dur).toFixed(2) + 's', endFrac * w - 3, 11);
  ctx.textAlign = 'left';
}

function updateClipInfo() {
  if (!clipAudioBuf) return;
  const dur = clipAudioBuf.duration;
  let s = +$('clip-start').value, e = +$('clip-end').value;
  if (s >= e) { s = e - 1; $('clip-start').value = s; }
  if (e <= s) { e = s + 1; $('clip-end').value = e; }
  const startSec = s / 1000 * dur, endSec = e / 1000 * dur;
  $('clip-start-val').textContent = startSec.toFixed(2) + 's';
  $('clip-end-val').textContent = endSec.toFixed(2) + 's';
  $('clip-info').textContent = `Trimmed: ${(endSec - startSec).toFixed(2)}s (original: ${dur.toFixed(2)}s)`;
  drawClipWaveform();
}

$('clip-start').addEventListener('input', updateClipInfo);
$('clip-end').addEventListener('input', updateClipInfo);

$('clip-close').addEventListener('click', () => {
  stopClipPreview();
  $('clip-modal').style.display = 'none';
  clipAudioBuf = null;
});
$('clip-modal').addEventListener('click', e => {
  if (e.target === $('clip-modal')) {
    stopClipPreview();
    $('clip-modal').style.display = 'none';
    clipAudioBuf = null;
  }
});

function stopClipPreview() {
  if (clipPreviewSrc) { try { clipPreviewSrc.stop(); } catch(_) {} clipPreviewSrc = null; }
  $('clip-preview').innerHTML = '&#9654; PREVIEW';
  $('clip-preview').classList.remove('previewing');
}

$('clip-preview').addEventListener('click', () => {
  if (clipPreviewSrc) { stopClipPreview(); return; }
  if (!clipAudioBuf) return;
  const dur = clipAudioBuf.duration;
  const startSec = +$('clip-start').value / 1000 * dur;
  const endSec = +$('clip-end').value / 1000 * dur;
  const ctx = Tone.context?.rawContext || new AudioContext();
  const src = ctx.createBufferSource();
  src.buffer = clipAudioBuf;
  src.connect(ctx.destination);
  src.onended = () => stopClipPreview();
  src.start(0, startSec, endSec - startSec);
  clipPreviewSrc = src;
  $('clip-preview').innerHTML = '&#9632; STOP';
  $('clip-preview').classList.add('previewing');
});

function encodeWavBlob(buf, startSample, endSample) {
  const sr = buf.sampleRate, ch = buf.numberOfChannels;
  const len = endSample - startSample;
  const dataSize = len * ch * 2;
  const ab = new ArrayBuffer(44 + dataSize);
  const v = new DataView(ab);
  const w = (o, s) => { for (let i = 0; i < s.length; i++) v.setUint8(o + i, s.charCodeAt(i)); };
  w(0,'RIFF'); v.setUint32(4, 36 + dataSize, true); w(8,'WAVE');
  w(12,'fmt '); v.setUint32(16,16,true); v.setUint16(20,1,true);
  v.setUint16(22, ch, true); v.setUint32(24, sr, true);
  v.setUint32(28, sr * ch * 2, true); v.setUint16(32, ch * 2, true);
  v.setUint16(34, 16, true); w(36,'data'); v.setUint32(40, dataSize, true);
  const chData = [];
  for (let c = 0; c < ch; c++) chData.push(buf.getChannelData(c));
  let off = 44;
  for (let i = startSample; i < endSample; i++) {
    for (let c = 0; c < ch; c++) {
      const s = Math.max(-1, Math.min(1, chData[c][i]));
      v.setInt16(off, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      off += 2;
    }
  }
  return new Blob([ab], { type: 'audio/wav' });
}

async function saveClipTrimmed(asNew) {
  if (!clipAudioBuf || clipSampleIdx < 0) return;
  const dur = clipAudioBuf.duration;
  const sr = clipAudioBuf.sampleRate;
  const startSec = +$('clip-start').value / 1000 * dur;
  const endSec = +$('clip-end').value / 1000 * dur;
  const startSample = Math.max(0, Math.floor(startSec * sr));
  const endSample = Math.min(clipAudioBuf.length, Math.floor(endSec * sr));
  if (endSample <= startSample) return;

  const trimmedBlob = encodeWavBlob(clipAudioBuf, startSample, endSample);
  const trimmedDur = +(endSec - startSec).toFixed(2);

  if (asNew) {
    const orig = sbank.getSample(clipSampleIdx);
    const entry = {
      name: (orig?.name || 'clip') + ' (trimmed)',
      prompt: orig?.prompt || '',
      duration: trimmedDur,
      audioBlob: trimmedBlob,
      ts: Date.now(),
    };
    try { entry.id = await sbank.store.save(entry); } catch(_) {}
    sbank.samples.push(entry);
    status.textContent = 'Saved trimmed clip!';
  } else {
    await sbank.replaceSample(clipSampleIdx, trimmedBlob, trimmedDur);
    status.textContent = 'Replaced with trimmed clip!';
  }

  stopClipPreview();
  rebuildSampleBank();
  buildMixer();
  $('clip-modal').style.display = 'none';
  clipAudioBuf = null;
  setTimeout(() => { if (status.textContent.includes('clip')) status.textContent = ''; }, 2500);
}

$('clip-save').addEventListener('click', () => saveClipTrimmed(true));
$('clip-replace').addEventListener('click', () => saveClipTrimmed(false));

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SAMPLE LIBRARY â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

$('open-library').addEventListener('click', () => {
  rebuildLibrary();
  $('lib-modal').style.display = '';
});
$('lib-close').addEventListener('click', () => { $('lib-modal').style.display = 'none'; });
$('lib-modal').addEventListener('click', e => { if (e.target === $('lib-modal')) $('lib-modal').style.display = 'none'; });

function rebuildLibrary() {
  const el = $('lib-list');
  el.innerHTML = '';

  if (!sbank.samples.length) {
    el.innerHTML = '<div style="text-align:center;color:#605080;font-size:10px;padding:20px;">No samples yet. Generate some with ACE-Step!</div>';
    return;
  }

  sbank.samples.forEach((sample, idx) => {
    const row = document.createElement('div');
    row.className = 'lib-item';

    const name = document.createElement('span');
    name.className = 'lib-name';
    name.textContent = sample.name;
    name.title = sample.prompt || sample.name;
    name.addEventListener('click', e => {
      e.stopPropagation();
      const oldName = sample.name;
      const input = document.createElement('input');
      input.type = 'text';
      input.value = oldName;
      input.style.cssText = 'flex:1;background:rgba(20,0,40,0.8);border:1px solid #c060ff;color:#d0b0ff;font-family:inherit;font-size:11px;padding:2px 6px;border-radius:3px;outline:none;';
      let done = false;
      const finish = async () => {
        if (done) return; done = true;
        const newName = input.value.trim() || oldName;
        if (newName !== oldName) {
          for (let s = 0; s < SAMPLE_SLOTS; s++) {
            if (synth.sampleNames[s] === oldName) synth.sampleNames[s] = newName;
          }
          await sbank.renameSample(idx, newName);
          buildMixer();
          rebuildSampleBank();
        }
        rebuildLibrary();
      };
      input.addEventListener('blur', finish);
      input.addEventListener('keydown', ev => { if (ev.key==='Enter') input.blur(); if (ev.key==='Escape') { input.value = oldName; input.blur(); } });
      name.replaceWith(input);
      input.focus();
      input.select();
    });

    const meta = document.createElement('span');
    meta.className = 'lib-meta';
    meta.textContent = `${sample.duration}s`;
    if (sample.ts) {
      const d = new Date(sample.ts);
      meta.textContent += ` \u00B7 ${d.toLocaleDateString()}`;
    }

    const play = document.createElement('button');
    play.className = 'btn';
    play.textContent = '\u25B6';
    play.addEventListener('click', async e => {
      e.stopPropagation();
      if (previewBtn === play) { stopPreview(); return; }
      stopPreview();
      try {
        const audioBuf = await decodeBlob(sample.audioBlob);
        const ctx = Tone.context?.rawContext || new AudioContext();
        const src = ctx.createBufferSource();
        src.buffer = audioBuf;
        src.connect(ctx.destination);
        src.onended = () => { if (previewBtn === play) stopPreview(); };
        src.start();
        previewSource = src;
        previewBtn = play;
        play.classList.add('previewing');
        play.textContent = '\u25A0';
      } catch(_) {}
    });

    const edit = document.createElement('button');
    edit.className = 'btn';
    edit.textContent = '\u2702';
    edit.title = 'Edit / Trim';
    edit.addEventListener('click', e => {
      e.stopPropagation();
      $('lib-modal').style.display = 'none';
      openClipEditor(idx);
    });

    const dl = document.createElement('button');
    dl.className = 'btn';
    dl.textContent = '\u2193';
    dl.title = 'Download WAV';
    dl.addEventListener('click', e => { e.stopPropagation(); downloadSample(sample); });

    const slots = document.createElement('span');
    slots.className = 'lib-slots';
    for (let s = 0; s < SAMPLE_SLOTS; s++) {
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.textContent = 'S' + (s + 1);
      btn.style.color = SLOT_COLORS[s];
      if (synth.sampleNames[s] === sample.name) btn.classList.add('active');
      btn.addEventListener('click', ev => { ev.stopPropagation(); assignToSlot(idx, s); rebuildLibrary(); });
      slots.appendChild(btn);
    }

    const del = document.createElement('button');
    del.className = 'btn';
    del.textContent = '\u00D7';
    del.addEventListener('click', async e => {
      e.stopPropagation();
      await sbank.deleteSample(idx);
      rebuildSampleBank();
      rebuildLibrary();
    });

    row.appendChild(name);
    row.appendChild(meta);
    row.appendChild(play);
    row.appendChild(edit);
    row.appendChild(dl);
    row.appendChild(slots);
    row.appendChild(del);
    el.appendChild(row);
  });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LOAD SAVED DATA â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
(async () => {
  // textures
  try {
    const saved = await api.loadSaved();
    if (saved.length) {
      saved.forEach((item,i) => addGalleryThumb(item.dataUrl,i));
      status.textContent = `${saved.length} saved texture(s) loaded`;
      setTimeout(() => { if(status.textContent.includes('loaded')) status.textContent=''; }, 2500);
    }
  } catch(_) {}
  // samples
  try {
    const saved = await sbank.loadSaved();
    if (saved.length) {
      rebuildSampleBank();
      buildMixer();
      status.textContent = `${saved.length} saved sample(s) loaded`;
      setTimeout(() => { if(status.textContent.includes('sample')) status.textContent=''; }, 2500);
    }
  } catch(_) {}
  // beat maps
  try {
    const maps = await mapStore.getAll();
    if (maps.length) rebuildMapsList(maps);
  } catch(_) {}
})();

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LORA STUDIO â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• COLLAPSIBLE SECTIONS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
document.querySelectorAll('.collapse-header[data-collapse]').forEach(header => {
  header.addEventListener('click', () => {
    const bodyId = header.dataset.collapse;
    const body = document.getElementById(bodyId);
    const arrow = header.querySelector('.collapse-arrow');
    if (body) body.classList.toggle('open');
    if (arrow) arrow.classList.toggle('open');
  });
});

const LORA_API = '/ace-api/v1/lora';

// LoRA collapsible toggle (has extra logic to refresh status on open)
document.getElementById('lora-toggle').addEventListener('click', () => {
  const body = document.getElementById('lora-body');
  const arrow = document.getElementById('lora-arrow');
  body.classList.toggle('open');
  arrow.classList.toggle('open');
  if (body.classList.contains('open')) refreshLoRAStatus();
});

// DOM refs
const loraDot = document.getElementById('lora-dot');
const loraStatusLabel = document.getElementById('lora-status-label');
const loraScaleSlider = document.getElementById('lora-scale');
const loraScaleVal = document.getElementById('lora-scale-val');
const loraPathInput = document.getElementById('lora-path');
const loraLoadBtn = document.getElementById('lora-load');
const loraUnloadBtn = document.getElementById('lora-unload');
const loraOnOffBtn = document.getElementById('lora-onoff');
const loraAdapterList = document.getElementById('lora-adapter-list');
const loraProgress = document.getElementById('lora-progress');
const loraTrainStatus = document.getElementById('lora-train-status');
const loraTrainBtn = document.getElementById('lora-train');
const loraStopBtn = document.getElementById('lora-stop');

async function refreshLoRAStatus() {
  try {
    const r = await fetch(`${LORA_API}/status`);
    const j = await r.json();
    const s = j.data || {};
    loraDot.className = 'lora-dot' + (s.active ? ' active' : s.loaded ? ' loaded' : '');
    loraStatusLabel.textContent = s.active ? 'Active' : s.loaded ? 'Loaded (off)' : 'No adapter loaded';
    loraScaleSlider.disabled = !s.loaded;
    loraUnloadBtn.disabled = !s.loaded;
    loraOnOffBtn.disabled = !s.loaded;
    loraOnOffBtn.textContent = s.active ? 'OFF' : 'ON';
    if (s.scale !== undefined) {
      loraScaleSlider.value = Math.round(s.scale * 100);
      loraScaleVal.textContent = s.scale.toFixed(1);
    }
  } catch(e) { loraStatusLabel.textContent = 'Status error'; }
}

// Load adapter
loraLoadBtn.addEventListener('click', async () => {
  const path = loraPathInput.value.trim();
  if (!path) return;
  loraLoadBtn.disabled = true;
  try {
    const r = await fetch(`${LORA_API}/load`, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({path}) });
    const j = await r.json();
    if (j.error) { loraStatusLabel.textContent = j.error; }
    else { await refreshLoRAStatus(); }
  } catch(e) { loraStatusLabel.textContent = 'Load failed'; }
  loraLoadBtn.disabled = false;
});

// Unload adapter
loraUnloadBtn.addEventListener('click', async () => {
  try {
    await fetch(`${LORA_API}/unload`, { method:'POST' });
    await refreshLoRAStatus();
  } catch(e) { loraStatusLabel.textContent = 'Unload failed'; }
});

// Toggle ON/OFF
loraOnOffBtn.addEventListener('click', async () => {
  const enable = loraOnOffBtn.textContent === 'ON';
  try {
    await fetch(`${LORA_API}/toggle`, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({enabled:enable}) });
    await refreshLoRAStatus();
  } catch(e) { loraStatusLabel.textContent = 'Toggle failed'; }
});

// Scale slider
loraScaleSlider.addEventListener('change', async () => {
  const scale = loraScaleSlider.value / 100;
  loraScaleVal.textContent = scale.toFixed(1);
  try {
    await fetch(`${LORA_API}/scale`, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({scale}) });
  } catch(_) {}
});
loraScaleSlider.addEventListener('input', () => {
  loraScaleVal.textContent = (loraScaleSlider.value / 100).toFixed(1);
});

// Adapter list
async function refreshAdapterList() {
  try {
    const r = await fetch(`${LORA_API}/list`);
    const j = await r.json();
    const adapters = j.data || [];
    loraAdapterList.innerHTML = '';
    if (!adapters.length) {
      loraAdapterList.innerHTML = '<div style="font-size:8px;color:#605080;padding:4px;">No adapters found</div>';
      return;
    }
    for (const a of adapters) {
      // Main adapter row (final or best available)
      const item = document.createElement('div');
      item.className = 'lora-adapter-item';
      const label = a.has_final ? 'final' : 'adapter';
      const ckptCount = a.checkpoints?.length || 0;
      item.innerHTML = `<span>${a.name}</span><span class="lora-ckpts">${label}${ckptCount ? ' + ' + ckptCount + ' ckpts' : ''}</span>`;
      item.addEventListener('click', () => {
        loraPathInput.value = a.path;
        loraPathInput.focus();
      });
      item.title = a.path;
      loraAdapterList.appendChild(item);

      // Show individual checkpoints as sub-items
      if (a.checkpoints?.length) {
        for (const ckpt of a.checkpoints) {
          const sub = document.createElement('div');
          sub.className = 'lora-adapter-item';
          sub.style.paddingLeft = '16px';
          sub.style.fontSize = '8px';
          sub.style.opacity = '0.7';
          sub.innerHTML = `<span>\u2514 ${ckpt.name}</span>`;
          sub.addEventListener('click', () => {
            loraPathInput.value = ckpt.path;
            loraPathInput.focus();
          });
          sub.title = ckpt.path;
          loraAdapterList.appendChild(sub);
        }
      }
    }
  } catch(e) { loraAdapterList.innerHTML = '<div style="font-size:8px;color:#ff6666;padding:4px;">Error loading adapters</div>'; }
}
document.getElementById('lora-refresh').addEventListener('click', refreshAdapterList);

// Training param sliders
function wireLoraSlider(id, valId, fmt) {
  const sl = document.getElementById(id);
  const vl = document.getElementById(valId);
  sl.addEventListener('input', () => { vl.textContent = fmt(sl.value); });
}
wireLoraSlider('lora-rank', 'lora-rank-val', v => v);
wireLoraSlider('lora-alpha', 'lora-alpha-val', v => v);
wireLoraSlider('lora-epochs', 'lora-epochs-val', v => v);
wireLoraSlider('lora-lr', 'lora-lr-val', v => {
  const exp = parseFloat(v);
  return exp === Math.round(exp) ? `1e${exp}` : `${Math.pow(10, exp).toExponential(0)}`;
});

// Preprocess
document.getElementById('lora-preprocess').addEventListener('click', async () => {
  const audioDir = document.getElementById('lora-audio-dir').value.trim();
  if (!audioDir) return;
  try {
    const r = await fetch(`${LORA_API}/preprocess`, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({audio_dir:audioDir}) });
    const j = await r.json();
    if (j.error) { loraTrainStatus.textContent = j.error; return; }
    if (j.data?.output_dir) document.getElementById('lora-tensor-dir').value = j.data.output_dir;
    startTrainingPoll();
  } catch(e) { loraTrainStatus.textContent = 'Preprocess request failed'; }
});

// Start training
loraTrainBtn.addEventListener('click', async () => {
  const tensorDir = document.getElementById('lora-tensor-dir').value.trim();
  if (!tensorDir) return;
  const params = {
    tensor_dir: tensorDir,
    rank: parseInt(document.getElementById('lora-rank').value),
    alpha: parseInt(document.getElementById('lora-alpha').value),
    max_epochs: parseInt(document.getElementById('lora-epochs').value),
    learning_rate: Math.pow(10, parseFloat(document.getElementById('lora-lr').value)),
  };
  loraTrainBtn.disabled = true;
  try {
    const r = await fetch(`${LORA_API}/train`, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(params) });
    const j = await r.json();
    if (j.error) { loraTrainStatus.textContent = j.error; loraTrainBtn.disabled = false; return; }
    loraStopBtn.disabled = false;
    startTrainingPoll();
  } catch(e) { loraTrainStatus.textContent = 'Train request failed'; loraTrainBtn.disabled = false; }
});

// Stop training
loraStopBtn.addEventListener('click', async () => {
  try { await fetch(`${LORA_API}/train/stop`, { method:'POST' }); } catch(_) {}
});

// Training status poll
let _loraPollId = null;
function startTrainingPoll() {
  if (_loraPollId) clearInterval(_loraPollId);
  _loraPollId = setInterval(async () => {
    try {
      const r = await fetch(`${LORA_API}/train/status`);
      const j = await r.json();
      const s = j.data || {};
      loraTrainStatus.textContent = s.status_message || '';
      if (s.max_epochs > 0) {
        const pct = Math.min(100, (s.current_epoch / s.max_epochs) * 100);
        loraProgress.style.width = pct + '%';
      }
      if (s.current_loss > 0) {
        loraTrainStatus.textContent += ` | loss: ${s.current_loss.toFixed(4)}`;
      }
      if (s.started_at && (s.is_running || s.is_preprocessing)) {
        const elapsed = Math.round((Date.now()/1000) - s.started_at);
        const m = Math.floor(elapsed/60), sec = elapsed%60;
        loraTrainStatus.textContent += ` | ${m}m${sec}s`;
      }
      if (!s.is_running && !s.is_preprocessing) {
        clearInterval(_loraPollId);
        _loraPollId = null;
        loraTrainBtn.disabled = false;
        loraStopBtn.disabled = true;
        if (!s.error) refreshAdapterList();
      }
    } catch(_) {}
  }, 3000);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ANIMATION LOOP â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function animate() {
  requestAnimationFrame(animate);
  const ad = synth.getAudioData();
  vis.update(ad);

  // loop progress
  if (synth.isPlaying) {
    const p = synth.getLoopProgress();
    loopBar.style.width = (p*100).toFixed(1)+'%';
    const totalBars = (synth.songMode && synth.arrangement.length) ? synth.arrangement.length : synth.loopLength;
    const currentBar = Math.floor(p * totalBars) + 1;
    loopPos.textContent = synth.songMode ? `S${currentBar}/${totalBars}` : `${currentBar}/${synth.loopLength}`;

    // highlight current step in sequencer
    const curStep = synth._currentStep;
    const curBar  = Math.floor(curStep / 16);
    const curCol  = curStep % 16;

    if (curStep !== prevHighlight) {
      // clear old highlight
      seqStepEls.forEach(s => s.el.classList.remove('current'));
      // highlight if we're viewing this bar
      if (curBar === seqBar) {
        for (let r = 0; r < SEQ_INSTRUMENTS.length; r++) {
          const idx = r * 16 + curCol;
          if (seqStepEls[idx]) seqStepEls[idx].el.classList.add('current');
        }
      }
      prevHighlight = curStep;
    }
  }
}
animate();
</script>
</body>
</html>
